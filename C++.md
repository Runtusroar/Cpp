## 1 简介

### 1.1 介绍

C++是一种静态类型的、编译式的、通用的，大小写敏感的不规则编程语言

> - 静态类型：变量的类型在编译时是已知的
> - 动态类型：变量的类型在运行时才会确定
> - 编译型语言：程序在执行前，须将源代码整体编译成机器码或可执行文件(编译器会对整个程序进行优化)
> - 解释性语言：程序在运行时，解释器会逐行解释并执行源代码

### 1.2 面向对象特性

C++支持面向对象的程序设计，包括面向对象开发的四大特性：

- 封装：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。
- 继承：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性
- 多态：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。
- 抽象：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。

### 1.3 C++组成

标准的C++由三个重要部分组成：

- 核心语言：提供了所有构件块，包括变量、数据类型和常量，等等
- C++标准库：提供了大量的函数，用于操作文件、字符串等
- 标准模板库(STL)：提供了大量的方法，用于操作数据结构等





## 2 基本语法

### 2.1 简单程序

通过一个简单的c++程序进行介绍

```c++
#include <iostream>		//头文件
using namespace std;	//命名空间：一种封装标识符的机制，用于防止命名冲突

int main(){		//主函数：程序开始执行的地方
	cout << "hello world";
    return 0;	//返回值：int类型，程序执行成功默认返回值为0
}
```

1. 头文件：程序预先需要使用的文件，里面包含了在之后的编码中要用到的类和函数

   > 头文件类型：
   >
   > 1.标准库头文件
   >
   > ```cpp
   > #include <iostream>
   > ```
   >
   > 2.自定义头文件
   >
   > ```cpp
   > #include "my_custom_header.h"
   > ```
   >
   > 3.第三方库头文件
   >
   > ```cpp
   > #include <vector>
   > ```



### 2.2 注释

注释：给程序员看的备注和说明，用于提高代码的可读性和可维护性，编译器会忽略注释

1. 单行注释

   ```cpp
   // 这是单行注释，用于注释一行代码
   ```

2. 多行注释

   ```cpp
   /*	这是多行注释
   	用于注释多行代码
   */	
   ```

   

### 2.3 语句

语句：构成程序的基本单位，表示执行的单个操作或指令，以分号`;`作为语句结束符

> 注意：语句以;号结尾，不是换行
>
> ```cpp
> //例如
> std::cout << "hello world";
> return 0;
> 
> std::cout
> << "hello world"
> ;
> return
> 0
> ;
> 
> std::cout << "hello world"; return 0;
> //这三种写法都不会报错，只是第一种更易读，输出结果都一样
> ```

语句块：用`{}`包裹的多个语句

```cpp
{
    std::cout << "hello world";
    std::cout << "this is cpp node"
}
```



### 2.4 C++程序代码组成

1. 预处理指令

   这些指令在编译前由预处理器处理，常见预处理指令`#include`用于包含头文件，以及`#define`用于定义宏

   ```cpp
   #include <iostream>
   #define PI 3.14159
   ```

2. 注释：用于解释代码，提高可读性，不参与编译

   ```cpp
   // 这是单行注释
   
   /*	这是
   	多行
   	注释
   */
   ```

3. 函数：执行特定任务的代码块，每个c++程序有且只有一个main函数作为程序的入口

   ```cpp
   int main(){
       return 0;
   }
   ```

4. 变量和数据类型：变量是数据的存储位置，不同的数据类型，存储的格式不同，解释也不一样

   ```cpp
   int number;
   double price;
   ```

5. 表达式和运输符：表达式由变量，常量、运算符组成，用于计算值

   ```cpp
   int sum = a + b;
   bool isEqual = (a == b);
   ```

6. 控制流语句：控制程序执行的顺序，包括条件语句(if、switch)和循环语句(for、while)

   ```cpp
   if(condition){
       //代码
   }
   
   for(int i = 1; i < 10; i++){
       //循环代码
   }
   ```

7. 类和对象：类是定义对象属性和行为的模板，对象是类的实例

   ```cpp
   class myClass{
       //类定义
   }
   
   myClass obj;	//创建类实例
   ```

8. 错误处理：处理异常的机制，`try`、`catch`、`throw`都用于错误处理

   ```cpp
   try{
       //可能抛出异常的代码
   }
   
   catch(exception& e){
       //异常处理
   }
   ```

9. 模板(泛编程)：用于创建泛型类或函数

   ```cpp
   template <typename T>
   T max(T x, T y) {
       return (x > y) ? x : y;
   }
   ```

10. 命名空间：用于组织代码，防止命名冲突

    ```cpp
    namespace myNamespace {
        //代码
    }
    ```




## 3 数据类型

数据类型分类：基本数据类型、复合数据类型、自定义数据类型、特殊数据类型

### 3.1 基本数据类型

| 数据类型      | 描述                                       | 大小(典型)                   | 存储标准(转为二进制规则)      |
| ------------- | ------------------------------------------ | ---------------------------- | ----------------------------- |
| `int`         | 整型，用于存储整数                         | 4字节                        | 补码系统                      |
| `short`       | 短整型，比整型小的整数类型                 | 2字节                        | 补码系统                      |
| `long`        | 长整型，比整型大的整数类型                 | 4字节(或8字节)               | 补码系统                      |
| `long long`   | 比`long`还大的整数类型                     | 8字节                        | 补码系统                      |
|               |                                            |                              |                               |
| `float`       | 单精度浮点数，用于存储小数                 | 4字节                        | IEEE754标准                   |
| `double`      | 双精度浮点数，用于存储大数和精度更高的小数 | 8字节                        | IEEE754标准                   |
| `long double` | 长双精度型                                 | 8字节(Windows) 16字节(Linux) | IEEE754标准                   |
|               |                                            |                              |                               |
| `char`        | 字符型，用于存储单个字符                   | 1字节                        | ASCLL编码                     |
| `wchar_t`     | 宽字符类型，用于存储单个字符               | 2字节(Windows) 4字节(Linux)  | UTF-16(Windows) UTF-32(Linux) |
| `char16_t`    | C++11 引入的字符类型                       | 2字节                        | UTF-16                        |
| `char32_t`    | C++11 引入的字符类型                       | 4字节                        | UTF-32                        |
|               |                                            |                              |                               |
| `bool`        | 布尔型，用于存储`true`和`false`            | 1字节                        | 1(true) 0(false)              |
| `void`        | 空类型，通常用于指定无返回值的函数         | 无                           | 无                            |

> 整数类型还有`signed`，`unsigned`修饰符，表述有符号和无符号位，实际上`long`，`short`也是修饰符



### 3.2 复合数据类型

复合数据类型：有基本数据类型构成的更加复杂的数据结构

| 数据类型         | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| 数组             | 相同类型数据的元素组合，存储在连续的内存位置                 |
| 结构体(`struct`) | 不同类型数据项的集合，每个数据项被称为成员                   |
| 联合(`union`)    | 联合允许在同一内存位置存储不同数据类型的数据，但是任一时刻只能存储其中一种类型的数据 |
| 类(`class`)      | 类是面向对象编程的基础，包含数据成员和函数成员               |
| 枚举(`enum`)     | 一种用户定义的类型，由一组命名的整型常量组成                 |
| 指针             | 存储内存地址的变量，可以指向某个类型的数据                   |
| 引用             | 变量的别名，给已经存在的变量起一个别名                       |
| 函数             | 函数也可以视为一种复合数据类型，因为可以接受参数并由返回值   |



### 3.3 非内置数据类型

| 数据类型    | 描述                  |
| ----------- | --------------------- |
| std::string | 字符串数据类型(UTF-8) |
| 模板类型    |                       |



## 4 字面值常量

字面值常量：指直接出现在代码中的固定值，这些值本身是不可变的。字面值常量可以是数字、字符、字符串的等基本数据类型的直接表示

> 注意：字面值常量也是具有数据类型的

### 4.1 整数字面值

| 前缀                            | 含义       | 示例      |
| ------------------------------- | ---------- | --------- |
| 无                              | 默认十进制 | `30`      |
| `0`(数字零)                     | 八进制     | `036`     |
| `0x`或`0X`(数字零和大小写字母x) | 十六进制   | `0x1e`    |
| `0b`或`0B`(数字零和大小写字母b) | 二进制     | `0b11110` |

| 后缀       | 含义            | 实例   |
| ---------- | --------------- | ------ |
| 无         | 默认位`int`类型 | `30`   |
| `u`或`U`   | `unsigned`类型  | `30u`  |
| `l`或`L`   | `long`类型      | `30L`  |
| `ll`或`LL` | `long long`类型 | `30LL` |

> 注意：
>
> ​    前缀用于指定整数的基数(进制)
>
> ​    后缀用于指定整数的类型和大小



### 4.2 浮点字面值

| 后缀     | 含义              | 示例    |
| -------- | ----------------- | ------- |
| 无       | 默认`double`类型  | `3.14`  |
| `f`或`F` | `float`类型       | `3.14f` |
| `l`或`L` | `long double`类型 | `3.14L` |

> 注意：与整数字面值不同，浮点型字面值没有用于指示类型的前缀



### 4.3 字符字面值

**单引号**括起来的**表示单个字符**的字面值。

| 类型        | 描述                                                         | 示例                                                         |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 普通字符    | 直接表示的单个字符                                           | `'s'`、`'8'`、`'?'`                                          |
| 转义序列    | 使用反斜杠 `\` 开头的特殊字符序列，用于表示无法直接表示或有特殊意义的字符 | `\n`(换行)、`\t`(水平制表符)、`\\`(反斜杠本身)、`\'`(单引号)<br/>`\"`(双引号)、`\0`(空字符)、`\b`(退格符)、`\r`(回车符) |
| Unicode字符 | `char16_t`: 使用`u`前缀，UTF-16编码。<br>`char32_t`: 使用`U`前缀，UTF-16编码 | `u'你'`(UTF-16)，`U'你'`(UTF-32)                             |
| 宽字符      | 使用`L`前缀表示的宽字符，Windows(UTF-16)，Linux(UTF-32)      | `L'好'`                                                      |

补充转义序列

| 转义序列     | 描述                                                         | 示例         |
| ------------ | ------------------------------------------------------------ | ------------ |
| `\nnn`       | 使用**八进制**数表示单个字符(ASCLL字符集，`nnn`表示1~3个八进制数) | `\44`        |
| `\xnn`       | 使用**十六进制**数表示单个字符(ASCLL字符集，`nn`表示1~2个十六进制数) | `\x24`       |
| `\unnnn`     | Unicode 字符（UTF-16，`nnnn` 是4个**十六进制**数字，C++11 新增） | `\u0024`     |
| `\Unnnnnnnn` | Unicode 字符（UTF-32，`nnnnnnnn` 是8个**十六进制**数字，C++11 新增） | `\U00000024` |



### 4.4 字符串字面值

字符串字面值：由双引号`""`包裹的字符序列

| 类型          | 前缀 | 示例                | 描述                                                 |
| ------------- | ---- | ------------------- | ---------------------------------------------------- |
| 普通字符串    | 无   | `"Hello, world"`    | 标准的字符数组，以空字符结尾(ASCLL字符集)            |
| 宽字符串      | `L`  | `L"宽字符串"`       | 宽字符数组，通常用于 Unicode 文本                    |
| UTF-8 字符串  | `u8` | `u8"你好"`          | UTF-8 编码的字符串字面值                             |
| UTF-16 字符串 | `u`  | `u"你好"`           | UTF-16 编码的字符串字面值                            |
| UTF-32 字符串 | `U`  | `U"你好"`           | UTF-32 编码的字符串字面值                            |
| 原始字符串    | `R`  | `R"(原始\n字符串)"` | 允许包含转义字符的原始字符串，即不对转义字符进行转义 |



### 4.5 布尔字面值

布尔字面值：只有两个值，`true`和`false`

| 特性     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 数据类型 | `bool`                                                       |
| 字面值   | `true`, `false`                                              |
| 意义     | `true` 表示逻辑真（等价于整数 `1`）<br>`false` 表示逻辑假（等价于整数 `0`） |
| 使用场景 | 条件判断、逻辑表达式、函数返回值                             |
| 整数转换 | `true` 转换为 `1`<br>`false` 转换为 `0`                      |
| 逆向转换 | 非零整数转换为 `true`<br>零值转换为 `false`                  |

### 4.6 空指针字面值

空指针字面值：用于表示一个不指向任何对象的指针

| 空指针字面值 | 类型        | 描述                              | 用途                                     | 示例                  |
| ------------ | ----------- | --------------------------------- | ---------------------------------------- | --------------------- |
| `NULL`       | 依赖于实现  | 在 C++11 之前用作空指针的标准表示 | 表示不指向任何对象的指针                 | `int* ptr = NULL;`    |
| `nullptr`    | `nullptr_t` | C++11 引入的空指针字面值          | 表示不指向任何对象的指针，提高类型安全性 | `int* ptr = nullptr;` |

> - **类型安全**：`NULL` 本质上是整数 `0`，可能会导致类型混淆和错误，尤其是在函数重载的场景中。`nullptr` 作为一个特殊的类型，能够避免这类问题。
> - **清晰语义**：`nullptr` 明确表示空指针，使代码更易于理解。

### 4.7 自定义字面值



## 5 变量

变量：在C++中，变量代表了内存中某个位置的数据

### 5.1 变量声明

变量声明：告诉编译器变量的类型和名称，但是不为其分配内存空间

语法：

- 声明变量但不定义：`extern 变量类型 变量名`
- 声明变量并定义：`变量类型 变量名`

```cpp
// 声明变量但不定义
extern int num;

// 声明变量并定义
int num;
```

> 注意：
>
> - C++程序中变量可以多次声明，但是只能定义一次
> - 仅仅声明变量不会为其分配内存
> - 声明并定义变量会为其分配内存
> - 在全局变量的情况下，可以在一个文件中使用 `extern` 关键字来声明变量，而在另一个文件中定义它。



### 5.2 变量定义

变量定义：告诉编译器变量的类型和名称，并为其分配内存空间

语法：`变量类型 变量名`

```cpp
//变量定义
int num;
```



### 5.3 变量初始化

变量初始化：定义变量的同时给变量赋值，被称为变量的初始化

1. **直接初始化**

- **语法**：`类型 变量(值)`
- **作用**：使用括号内的值，来初始化变量
- **示例**

```cpp
int num(10);
```



2. **赋值初始化**

- **语法**：`类型 变量 = 值`
- **作用**：使用等号右侧的值，来初始化变量
- **示例**

```cpp
char ch = 'a';
```



3. **列表初始化**

- **语法**：`类型 变量{值}`
- **作用**：使用花括号内的值，来初始化变量，并防止数据丢失(窄化转化)
- **示例**

```cpp
int number{10};
```

> 窄化转化：
>
> - **从浮点数到整数的转换**：
>   - 浮点数可能包含小数部分，转换为整数时，小数部分会被丢弃，例如，从 `3.14` 转换为 `3`。
> - **从大整数类型到小整数类型的转换**：
>   - 如果一个大的整数值（如 `long long`）无法完整地被存储在一个小的整数类型（如 `int`）中，这种转换可能导致数据丢失或溢出。
> - **从整数类型到布尔类型的转换**：
>   - 任何非零整数在转换为布尔类型时都会变成 `true`，零变成 `false`。
> - **从大范围浮点数到小范围浮点数的转换**：
>   - 如从 `double` 类型到 `float` 类型的转换可能导致精度损失。
>
> 
>
> ### C++11 列表初始化防止窄化转换
>
> 使用 `{}` 进行列表初始化时，C++11 会检查是否存在窄化转换：
>
> - **如果有窄化转换**：编译器会拒绝这种初始化，编译过程中会报错。
> - 示例
>   - `int x{7.9};` // 错误：浮点数到整数的窄化转换
>   - `char y{300};` // 错误：超出 `char` 范围的窄化转换



4. **值初始化**

- **语法**：`类型 变量{}`
- **作用**：对基本类型变量进行零初始化，对类类型变量调用默认构造函数
- **示例**

```cpp
int e{}; // 初始化为 0
double f{}; // 初始化为 0.0
```



5. **聚合初始化**

- **语法**：适用于数组和结构体，使用花括号 `{}` 包围初始值列表。
- **作用**：初始化数组元素或结构体成员。
- **示例**

```cpp
int arr[3]{1, 2, 3};
struct Point { int x; int y; } p{10, 20};
```



6. **构造函数初始化(对于类对象)**

- **语法**：`类名 变量名(参数列表);`
- **作用**：调用类的构造函数来初始化类对象。
- **示例**

```cpp
std::string str("Hello, Constructor");
std::vector<int> vec(10, 0); // 10个元素，每个都是0
```





### 5.4 命名规则

在C++中，变量的命名遵循着一定的规则，这些规则确保了代码的可读性和一致性

1. **字符集**

- 变量名只能包含字母（`a-z`，`A-Z`）、数字（`0-9`）和下划线（`_`）。
- 变量名必须以字母或下划线开头。不能以数字开头。



2. **区分大小写**

- C++ 是区分大小写的语言。因此，`myVar`、`myvar` 和 `MYVAR` 是三个不同的变量。



3. **关键字保留**

- 不能使用 C++ 的关键字作为变量名，如 `int`, `double`, `return`, `if` 等

> ### 最佳实践
>
> 1. **有意义的命名**：
>    - 使用描述性的名称来命名变量，使其能够清晰地表达变量的用途或意图，如 `userAge`, `totalSum`。
> 2. **命名风格**：
>    - **驼峰命名法**（CamelCase）：每个单词的首字母大写，除了第一个单词，如 `studentName`。
>    - **下划线命名法**（snake_case）：单词之间使用下划线分隔，全部小写，如 `student_name`。
> 3. **避免使用单个字符**：
>    - 除了在循环或临时变量中，避免使用像 `i`, `j`, `k` 这样的单个字符作为变量名。
> 4. **常量命名**：
>    - 常量通常使用全大写字母，单词之间用下划线分隔，如 `MAX_COUNT`。
> 5. **避免缩写**：
>    - 除非缩写非常常见和明确（如 `info` 代表 `information`），否则尽量避免使用缩写。
>
> **示例：**
>
> ```cpp
> int itemCount;          // 驼峰命名
> double shipping_cost;   // 下划线命名
> const int MAX_ITEMS = 100; // 常量命名
> ```



### 5.5 作用域

变量作用域：定义了变量在程序中的**可见性**和**生命周期**，根据变量定义的位置和方式，可以将变量的作用域分为以下几种



1. **局部作用域**（Local Scope）

- **定义**：在函数或代码块（如 `if`, `for`, `while` 块）内部定义的变量。
- **特点**
  - 变量只在定义它的函数或代码块内部可见。
  - 当控制流离开该函数或代码块时，这些变量将被销毁。



2. **全局作用域**（Global Scope）

- **定义**：在所有函数之外定义的变量。
- **特点**
  - 全局变量在整个程序的任何部分都是可见的，从定义点开始到程序结束。
  - 全局变量的生命周期贯穿整个程序。



3. **文件作用域**（File Scope）

- **定义**：使用 `static` 关键字在文件级别定义的变量。
- **特点**
  - 这些变量在整个文件中都是可见的，但不能被其他文件访问。



4. **类作用域**（Class Scope）

- **定义**：在类定义内部定义的变量（即类的成员变量）。
- **特点**
  - 成员变量在整个类中都是可见的，并且它们的生命周期与类的对象实例相关联。



5. **命名空间作用域**（Namespace Scope）

- **定义**：在命名空间内定义的变量。
- **特点**
  - 这些变量在声明它们的命名空间内是可见的，并且可以通过适当的命名空间限定符在其他地方访问。



**示例**

```cpp
#include <iostream>

int globalVar; // 全局变量

void function() {
    int localVar; // 局部变量
    static int staticVar; // 具有文件作用域的静态变量
}

class MyClass {
public:
    int memberVar; // 类作用域
};

namespace MyNamespace {
    int namespaceVar; // 命名空间作用域
}

int main() {
    // 使用 globalVar, localVar 不可见
    return 0;
}
```



### 5.6 常量

| 常量类型         | 描述                                 | 示例                               |
| ---------------- | ------------------------------------ | ---------------------------------- |
| 字面量常量       | 直接表示值本身的常量                 | `5`, `3.14`, `'a'`                 |
| `const` 常量     | 使用 `const` 关键字声明的不可变变量  | `const int MAX_SIZE = 100;`        |
| 枚举常量         | 用户定义的包含一组命名整型常量的类型 | `enum Color { RED, GREEN, BLUE };` |
| 宏常量(不推荐)   | 使用预处理器 `#define` 定义的常量    | `#define PI 3.14159`               |
| `constexpr` 常量 | C++11 引入的编译时常量               | `constexpr int SQUARE = 10 * 10;`  |

> - 对于需要在编译时确定值的场合，使用 `constexpr`。
> - 对于运行时不变的值，使用 `const`。
> - 避免使用宏常量（`#define`），因为它们不受类型检查的约束，可能导致不可预期的错误。
> - `const` 常量必须在声明时初始化，因为之后不能更改它们的值。
> - 有一个普遍的约定是将全局常量和宏常量的名字全部大写，以区分它们与普通变量和局部常量。



## 6 类型转换

类型转换是一个重要概念，它允许在不同的数据类型之间转换值。C++ 提供了几种类型转换机制，每种机制都有其用途和注意事项。

### 6.1 显式类型转换

1. **C 风格类型转换**：
   - 语法：`(类型)表达式`
   - 示例：`int x = (int)3.14;`
   - 注意事项：不推荐使用，因为它不够安全和明确。
2. **`static_cast`**：
   - 语法：`static_cast<类型>(表达式)`
   - 用途：用于非多态类型的转换。
   - 示例：`double y = static_cast<double>(x);`
3. **`dynamic_cast`**：
   - 语法：`dynamic_cast<类型>(表达式)`
   - 用途：主要用于处理具有多态性的对象。
   - 示例：`Base* b = dynamic_cast<Base*>(d);`（其中 `d` 是派生类的指针）
4. **`const_cast`**：
   - 语法：`const_cast<类型>(表达式)`
   - 用途：用于修改类型的 `const` 或 `volatile` 属性。
   - 示例：`const int* pci = const_cast<int*>(&ci);`
5. **`reinterpret_cast`**：
   - 语法：`reinterpret_cast<类型>(表达式)`
   - 用途：用于位级别的重新解释。
   - 示例：`int* ip = reinterpret_cast<int*>(fp);`（其中 `fp` 是一个浮点数的指针）



### 6.2 隐式类型转换

| 特点                                 | 常见场景                                 | 示例                                                         |
| ------------------------------------ | ---------------------------------------- | ------------------------------------------------------------ |
| 自动进行，可能导致数据丢失或意外行为 | 算术运算、函数调用、赋值                 | `int i = 5; double d = 2.5; double result = i * d; // i 被隐式转换为 double` |
| 编译器自动执行，无需程序员显式指定   | 混合不同类型的表达式，传递函数参数       | `void func(double x); int num = 10; func(num); // num 被隐式转换为 double` |
| 便利性和风险并存                     | 将一种类型的表达式赋值给另一种类型的变量 | `double pi = 3.14; int a = pi; // pi 被隐式转换为 int`       |



## 7 运算符

在 C++ 中，运算符是用于执行特定操作的符号或关键字。

### 7.1 算术运算符

| 运算符 | 作用                     | 示例                             |
| ------ | ------------------------ | -------------------------------- |
| `+`    | 合并两个数值。           | `int sum = 5 + 3; // sum = 8`    |
| `-`    | 从一个数中减去另一个数。 | `int diff = 5 - 3; // diff = 2`  |
| `*`    | 将两个数相乘。           | `int prod = 5 * 3; // prod = 15` |
| `/`    | 将一个数除以另一个数。   | `int quot = 10 / 2; // quot = 5` |
| `%`    | 返回两个数相除的余数。   | `int rem = 5 % 2; // rem = 1`    |



### 7.2 关系运算符

| 运算符 | 作用                               | 示例                                                         |
| ------ | ---------------------------------- | ------------------------------------------------------------ |
| `==`   | 比较两个值是否相等。               | `bool isEqual = (5 == 3); // isEqual = false`                |
| `!=`   | 比较两个值是否不相等。             | `bool isNotEqual = (5 != 3); // isNotEqual = true`           |
| `<`    | 检查一个值是否小于另一个值。       | `bool isLess = (5 < 3); // isLess = false`                   |
| `>`    | 检查一个值是否大于另一个值。       | `bool isGreater = (5 > 3); // isGreater = true`              |
| `<=`   | 检查一个值是否小于或等于另一个值。 | `bool isLessOrEqual = (5 <= 5); // isLessOrEqual = true`     |
| `>=`   | 检查一个值是否大于或等于另一个值。 | `bool isGreaterOrEqual = (5 >= 3); // isGreaterOrEqual = true` |



### 7.3 逻辑运算符

| 运算符 | 作用                                         | 示例                                                   |
| ------ | -------------------------------------------- | ------------------------------------------------------ |
| `&&`   | 如果两个操作数都为真，则结果为真。           | `bool result = (5 > 3) && (2 < 3); // result = true`   |
| `\|\|` | 如果两个操作数中至少有一个为真，则结果为真。 | `bool result = (5 < 3) \|\| (2 < 3); // result = true` |
| `!`    | 取反操作数的布尔值。                         | `bool result = !(5 < 3); // result = true`             |



### 7.4 赋值运算符

| 运算符 | 作用                                                     | 示例                   |
| ------ | -------------------------------------------------------- | ---------------------- |
| `=`    | 将右侧操作数的值赋给左侧操作数。                         | `int a = 5; // a = 5`  |
| `+=`   | 将左侧操作数与右侧操作数相加，然后将结果赋给左侧操作数。 | `a += 2; // a = a + 2` |
| `-=`   | 从左侧操作数中减去右侧操作数，然后将结果赋给左侧操作数。 | `a -= 2; // a = a - 2` |
| `*=`   | 将左侧操作数与右侧操作数相乘，然后将结果赋给左侧操作数。 | `a *= 2; // a = a * 2` |
| `/=`   | 将左侧操作数除以右侧操作数，然后将结果赋给左侧操作数。   | `a /= 2; // a = a / 2` |
| `%=`   | 将左侧操作数对右侧操作数取模，然后将结果赋给左侧操作数。 | `a %= 2; // a = a % 2` |



### 7.5 递增和递减

| 运算符 | 作用                                                         | 示例                       |
| ------ | ------------------------------------------------------------ | -------------------------- |
| `++`   | 增加变量的值。前缀形式（`++a`）先增加再返回值，后缀形式（`a++`）先返回值再增加。 | `int a = 5; a++; // a = 6` |
| `--`   | 减少变量的值。前缀形式（`--a`）先减少再返回值，后缀形式（`a--`）先返回值再减少。 | `int a = 5; a--; // a = 4` |



### 7.6 位运算符

| 运算符 | 作用                                   | 示例                                  |
| ------ | -------------------------------------- | ------------------------------------- |
| `&`    | 对两个数的二进制位执行逐位与操作。     | `int result = 5 & 3; // result = 1`   |
| `\|`   | 对两个数的二进制位执行逐位或操作。     | `int result = 5 \| 3; // result = 7`  |
| `^`    | 对两个数的二进制位执行逐位异或操作。   | `int result = 5 ^ 3; // result = 6`   |
| `~`    | 对一个数的二进制位执行逐位取反操作。   | `int result = ~5; // result = -6`     |
| `<<`   | 将一个数的二进制位向左移动指定的位数。 | `int result = 5 << 1; // result = 10` |
| `>>`   | 将一个数的二进制位向右移动指定的位数。 | `int result = 5 >> 1; // result = 2`  |



### 7.7 三元运算符

| 运算符 | 作用                                       | 示例                                                         |
| ------ | ------------------------------------------ | ------------------------------------------------------------ |
| `?:`   | 根据条件表达式的真值，选择两个值中的一个。 | `int result = (a > b) ? a : b; // 如果 a > b，result = a，否则 result = b` |



### 7.8 类型转换

| 运算符             | 作用                                        | 示例                                                         |
| ------------------ | ------------------------------------------- | ------------------------------------------------------------ |
| `static_cast`      | 用于非多态类型的转换。                      | `double pi = 3.14159; int n = static_cast<int>(pi); // n = 3` |
| `dynamic_cast`     | 用于多态类型的安全转换。                    | `Base* b = dynamic_cast<Base*>(d); // d 是派生类的指针`      |
| `const_cast`       | 用于修改类型的 `const` 或 `volatile` 属性。 | `const int* pci; int* pi = const_cast<int*>(pci);`           |
| `reinterpret_cast` | 用于不同类型之间的低级转换。                | `long p; int* ip = reinterpret_cast<int*>(&p);`              |



### 7.9 优先级

| 优先级 | 运算符                       | 结合律 | 描述             |
| ------ | ---------------------------- | ------ | ---------------- |
| 1      | `::`                         | 左到右 | 作用域解析运算符 |
| 2      | `++` `--` (后缀)             | 左到右 | 后缀递增/递减    |
| 2      | `()`                         | 左到右 | 函数调用         |
| 2      | `[]`                         | 左到右 | 数组下标         |
| 2      | `.` `->`                     | 左到右 | 成员访问         |
| 2      | `typeid`                     | 左到右 | 类型信息         |
| 3      | `++` `--` (前缀)             | 右到左 | 前缀递增/递减    |
| 3      | `+` `-` `!` `~`              | 右到左 | 一元运算符       |
| 3      | `static_cast` `dynamic_cast` | 右到左 | 类型转换运算符   |
| 3      | `sizeof` `alignof`           | 右到左 | 大小与对齐       |
| 4      | `*` `/` `%`                  | 左到右 | 乘法/除法/取模   |
| 5      | `+` `-`                      | 左到右 | 加法/减法        |
| 6      | `<<` `>>`                    | 左到右 | 位移运算符       |
| 7      | `<` `<=` `>` `>=`            | 左到右 | 关系运算符       |
| 8      | `==` `!=`                    | 左到右 | 相等性运算符     |
| 9      | `&`                          | 左到右 | 按位与           |
| 10     | `^`                          | 左到右 | 按位异或         |
| 11     | `\|`                         | 左到右 | 按位或           |
| 12     | `&&`                         | 左到右 | 逻辑与           |
| 13     | `\|\|`                       | 左到右 | 逻辑或           |
| 14     | `?:`                         | 右到左 | 三元条件运算符   |
| 15     | `=` `+=` `-=` `*=` `/=` `%=` | 右到左 | 赋值运算符       |
| 15     | `<<=` `>>=` `&=` `^=` `\|=`  | 右到左 | 复合赋值运算符   |
| 16     | `,`                          | 左到右 | 逗号运算符       |

> 简而言之：一元运算符 > 二元运算符 > 三元运算符 > 赋值运算符



## 8 语句

在C++中，语句是构成程序的基本单位，用于表达特定的操作或逻辑。

### 8.1 表达式语句

| **特性**     | **描述**                                                     |
| ------------ | ------------------------------------------------------------ |
| 定义         | 由一个表达式和一个终止的分号构成。用于计算表达式并标记语句结束。 |
| 表达式的类型 | - 赋值表达式（例如 `a = 5;`）<br>- 算术运算（例如 `a + b;`）<br>- 函数调用（例如 `print("Hello");`）<br>- 递增或递减操作（例如 `counter++;`）<br>- 逻辑运算（例如 `a && b;`） |
| 作用         | 改变程序状态，例如修改变量的值或调用函数。                   |
| 分号的重要性 | 分号是区分不同语句的关键，表示一个表达式的结束。             |
| 空表达式语句 | 只包含一个分号的语句（`；`），不执行任何操作，有时用于循环体中。 |
| 使用场景     | 在循环、条件语句中更新或检查变量，以及在函数调用中常见。     |



### 8.2 复合语句

复合语句（也称为块语句）是一种重要的语句结构，用于将多个语句组合成一个单一的执行块。

| **特性**         | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| 定义和结构       | 由一对大括号 `{}` 包围，内部可以包含多个语句。               |
| 作用域           | 复合语句内声明的变量只在大括号内部可见和可用，提供块级作用域。 |
| 用途             | - 控制流结构（如`if`、`for`、`while`）中的代码块<br>- 函数体<br>- 创建局部作用域 |
| 初始化和清理     | 进入复合语句时执行变量声明和初始化，离开时销毁自动存储期的变量。 |
| 与控制结构的结合 | 允许在条件判断或循环迭代中执行多个语句。                     |
| 空复合语句       | 不包含任何语句的复合语句（`{}`）是合法的，有时用于语法要求但逻辑不需要执行任何操作的场合。 |
| 异常处理         | 可以包含异常处理结构（如`try-catch`块），用于处理块内发生的异常。 |



### 8.3 条件语句

**条件控制语句**：作用是根据给定的条件来决定程序的执行路径。

1. **if语句**

```cpp
if (表达式1) {
    // 表达式1为真，则执行
} else if (表达式2) {
    // 表达式2为真，则执行
} else {
    // 表达式1、2都为假，则执行
}
```

> **注意：**在C++中，任何非零的数值或非空的指针都被视为`true`，而零值或空（`nullptr`）指针被视为`false`。



2. **switch语句**

**语法：**

```cpp
switch (expression) {
    case value1:
        // 代码块1
        break;	//可选
    case value2:
        // 代码块2
        break;	//可选
    // 更多 case...
    default:
        // 默认代码块
}
```

**示例：**

```cpp
#include <iostream>
#include <cctype>  // 用于字符转换函数

int main() {
    std::cout << "请输入成绩等级（A、B、C、D）: ";
    char str = std::cin.get();
    str = std::toupper(str);  // 将输入转换为大写字母

    switch (str) {
        case 'A':
            std::cout << "优秀";
            break;
        case 'B':
            std::cout << "良好";
            break;
        case 'C':
            std::cout << "及格";
            break;
        case 'D':
            std::cout << "仍需努力";
            break;
        default:
            std::cout << "无效输入。请输入 A、B、C 或 D。";
    }

    return 0;
}
```

> 注意：
>
> - **switch** 语句中的 **expression** 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
> - 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
> - case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
> - 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
> - 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
> - 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 *继续* 后续的 case，直到遇到 break 为止。
> - 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。



### 8.4 循环语句

在C++中，循环语句是用于重复执行一段代码直到满足特定条件的关键结构。

1. **`for循环`**

**语法**

```cpp
for (initialization; condition; increment) {
    // 循环体
}
```

> **执行顺序**
>
> 1. **初始化表达式**：循环开始前执行一次。
> 2. **条件表达式**：在每次循环开始前检查。如果条件为真，执行循环体；如果为假，循环终止。
> 3. **循环体**：如果条件为真，执行循环体内的语句。
> 4. **增量表达式**：循环体内的语句执行完毕后，增量表达式执行。
> 5. 返回第2步，直到条件表达式为假。

**示例**

```cpp
for (int i = 0; i < 5; i++) {
    std::cout << i << " ";
}
```



2. **`while循环`**

**语法**

```cpp
while (condition) {
    // 循环体
}
```

> **执行顺序**
>
> 1. **条件检查**：在每次循环的开始，首先检查条件表达式。
>    - 如果条件表达式的结果为`true`（非零），则继续执行循环。
>    - 如果条件表达式的结果为`false`（零），则跳出循环，继续执行循环之后的代码。
> 2. **执行循环体**：如果条件为`true`，执行循环体内的语句。
> 3. **回到步骤1**：循环体执行完后，再次回到第一步，重新检查条件表达式。
>
> 循环会继续这个过程，直到条件表达式的结果为`false`。

**示例**

```cpp
int i = 0;
while (i < 5) {
    std::cout << i << " ";
    i++;  // 修改循环变量，确保循环最终能够结束
}
```



3. **`do-while循环`**

**语法**

```cpp
do {
    // 循环体
} while (condition);
```

> **执行顺序**
>
> 1. **执行循环体**：首先执行循环体内的语句。
> 2. **条件检查**：在循环体执行之后检查条件表达式。
>    - 如果条件为`true`，重复循环。
>    - 如果条件为`false`，结束循环，执行循环之后的代码。

**示例**

```cpp
int count = 0;
do {
    std::cout << "执行循环体" << std::endl;
    count++;
} while (count < 5);
```



### 8.5 跳转语句

| 跳转语句   | 用途                         | 示例                           | 特点                                                         |
| ---------- | ---------------------------- | ------------------------------ | ------------------------------------------------------------ |
| `break`    | 退出循环或`switch`语句       | `if (i == 5) break;`           | - 在循环或`switch`中使用<br>- 防止执行下一个`case`或继续循环 |
| `continue` | 跳过当前循环迭代的剩余部分   | `if (i == 5) continue;`        | - 只在循环内部使用<br>- 直接开始下一次迭代                   |
| `return`   | 从函数返回值并结束函数       | `return a + b;`                | - 适用于所有函数<br>- 无返回值函数中可用于提前退出           |
| `goto`     | 无条件跳转到同一函数内的标记 | `goto label; ... label: ... ;` | - 功能强大但不推荐<br>- 可导致代码结构混乱和难以维护         |



### 8.6 声明语句

| 类型           | 定义                         | 语法                                                         | 示例                                                     |
| -------------- | ---------------------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| 变量声明       | 指定变量的类型和名称         | `type identifier;`<br>`type identifier = value;`             | `int a;`<br>`double b = 3.14;`                           |
| 函数声明       | 指定函数的返回类型和参数列表 | `returnType functionName(parameterList);`                    | `void printMessage();`<br>`int add(int a, int b);`       |
| 类和结构体声明 | 定义一个新类型的结构或类     | `class ClassName {...};`<br>`struct StructName {...};`       | `class Car {...};`<br>`struct Point {...};`              |
| 类型别名声明   | 为现有类型创建新名称         | `using NewName = ExistingType;`<br>`typedef ExistingType NewName;` | `using IntPtr = int*;`<br>`typedef unsigned long ulong;` |
| 枚举声明       | 定义一个枚举类型             | `enum EnumName {value1, value2, ...};`                       | `enum Color {RED, GREEN, BLUE};`                         |
| 模板声明       | 定义类型安全的函数或类的模板 | `template <typename T> ...`                                  | `template <typename T> T getMax(T a, T b);`              |
| 命名空间声明   | 定义包含相关标识符的命名空间 | `namespace NamespaceName {...}`                              | `namespace MyNamespace {...}`                            |



### 8.7 空语句

| 特性         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 空语句仅包含一个分号（`;`），没有任何其他内容。              |
| **用途**     | 1. 作为循环结构中的占位符，当循环体不需要执行任何代码时。<br>2. 有条件的执行，当某些条件下不需要执行任何操作时。 |
| **示例**     | - 循环中的空语句：<br> `for (int i = 0; i < 100 && !found; i++) { if (array[i] == target) found = true; }`<br>- 条件语句中的空语句：<br> `if (condition) { ; } else { performAction(); }` |
| **注意事项** | - 避免误用：在不适当的地方使用可能导致逻辑错误。<br>- 代码清晰：尽量减少使用，以保持代码的可读性。 |
| **替代方案** | 尽可能使用更清晰的代码结构替代空语句，如条件语句或循环，以明确代码意图。 |



### 8.8 异常处理语句

| 语句       | 语法示例                                         | 描述                                                         | 用途                                                         | 示例用法                                                     |
| ---------- | ------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `try`      | `try { /* 代码块 */ }`                           | 定义一个尝试执行的代码块，其中的代码可能会抛出异常。         | 围绕可能抛出异常的代码，提供了一种尝试执行某些操作的方法。   | `try { /* 可能抛出异常的代码 */ }`                           |
| `catch`    | `catch (异常类型 异常处理器) { /* 处理代码 */ }` | 捕获由`try`块中抛出的特定类型的异常，并执行相应的处理代码。  | 处理`try`块中抛出的特定类型的异常。                          | `catch (const std::runtime_error& e) { /* 处理运行时错误 */ }`<br>`catch (...) { /* 处理所有类型的异常 */ }` |
| `throw`    | `throw 异常对象;`                                | 抛出一个异常对象。如果在`catch`块内部使用，则重新抛出当前异常。 | 在检测到异常情况时抛出异常，以供`catch`块捕获和处理。        | `throw std::runtime_error("错误发生");`<br>`throw; // 在catch块内重新抛出当前异常` |
| `noexcept` | `void functionName() noexcept;`                  | 指定函数不会抛出异常。用于函数声明或函数定义。               | 指示函数保证不抛出异常，有助于编译器优化和表明函数的异常安全性。 | `void myFunction() noexcept;`<br>`bool isSafe() noexcept(true);` |

> **语法规范：**
>
> - `try`块应该紧跟着那些可能抛出异常的代码。
> - 语法规范要求`try`块后必须至少有一个`catch`块。
> - `catch`块用于捕获和处理特定类型的异常。
> - 每个`catch`块只能捕获一种异常类型。如果需要处理多种类型的异常，应该使用多个`catch`块。
> - `catch`块应紧跟在`try`块之后。
> - 使用`catch (...)`可以捕获所有类型的异常，但应谨慎使用。
> - 使用`throw`关键字抛出异常。可以抛出任何类型的对象，但建议抛出继承自`std::exception`的对象。
> - 在`catch`块中使用裸`throw`语句可以重新抛出当前捕获的异常。
> - 自定义异常应该继承自`std::exception`或其派生类，并覆写`what()`方法。
> - 使用`noexcept`关键字指明函数不会抛出异常。
> - 确保`catch`块中的代码不会抛出异常，除非该异常将被另一个`catch`块捕获。
> - 在函数声明中使用`noexcept`关键字可以提高程序性能，因为编译器可以对不抛出异常的函数进行优化。

**示例：**

```cpp
#include <iostream>

int main() {

	try {
		throw 1;
	}
	catch (int) {
		std::cout << "程序出现异常";
		return 1;
	}

	std::cout << "程序运行正常";
	return 0;
}
```



## 9 小练习

用一些小练习巩固学习成果

### 9.1 判断质数

质数：质数（Prime Number）是大于1的自然数，它们的特点是只有两个正因数：1和它本身。换句话说，质数不能被除了1和它自身以外的任何正整数整除。

> 1. **定义**：质数是只有两个不同的正除数（1和它本身）的大于1的自然数。
> 2. **最小的质数**：最小的质数是2，它也是唯一的偶数质数。之后的质数是3、5、7、11、13等。
> 3. **无限性**：质数是无限的，也就是说，没有最大的质数。这是数论中的一个重要定理，由欧几里得首次证明。
> 4. **重要性**：质数在数论中扮演着核心角色。它们是整数环的基本构建块，因为每个大于1的整数都可以唯一地分解为质数的乘积（这被称为质因数分解）。
> 5. **检测质数**：确定一个给定的大整数是否为质数是计算上非常困难的问题，尤其是对于非常大的数。然而，这个问题对于密码学等领域非常重要。

**一个容易想到的写法：**

```cpp
#include <iostream>

bool isPrime(int number) {
	if (number == 1) {
		return false;
	}

	if (number == 2) {
		return true;
	}

	for (int i = 3; i < number; i++) {
		if (number % i == 0) {
			return false;
		}
	}

	return true;
}

int main() {

	//提示
	std::cout << "请输入一个正整数：";

	// 获取用户输入
	int number;
	std::cin >> number;
	bool result = isPrime(number);

	if (result) {
		std::cout << number << "是质数";
	}
	else
	{
		std::cout << number << "不是质数";
	}
}
```

**一个优化方案：**

```cpp
#include <iostream>

bool isPrime(int number) {
    if (number <= 1) {
        return false; // 小于等于1的数不是质数
    }
    if (number <= 3) {
        return true; // 2和3是质数
    }

    // 如果能被2或3整除，不是质数
    if (number % 2 == 0 || number % 3 == 0) {
        return false;
    }

    // 检查从5开始的所有数字，直到平方根
    for (int i = 5; i * i <= number; i += 6) {
        if (number % i == 0 || number % (i + 2) == 0) {
            return false;
        }
    }
    return true;
}

int main() {
    int number;
    std::cout << "请输入一个整数: ";
    std::cin >> number;

    if (std::cin.fail()) {
        std::cout << "输入无效，需要输入一个整数。" << std::endl;
        return 1; // 输入错误，返回1
    }

    if (isPrime(number)) {
        std::cout << number << " 是质数。" << std::endl;
    }
    else {
        std::cout << number << " 不是质数。" << std::endl;
    }

    return 0; // 程序正常结束
}
```

