## 1 简介

### 1.1 介绍

C++是一种静态类型的、编译式的、通用的，大小写敏感的不规则编程语言

> - 静态类型：变量的类型在编译时是已知的
> - 动态类型：变量的类型在运行时才会确定
> - 编译型语言：程序在执行前，须将源代码整体编译成机器码或可执行文件(编译器会对整个程序进行优化)
> - 解释性语言：程序在运行时，解释器会逐行解释并执行源代码

### 1.2 面向对象特性

C++支持面向对象的程序设计，包括面向对象开发的四大特性：

- 封装：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。
- 继承：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性
- 多态：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。
- 抽象：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。

### 1.3 C++组成

标准的C++由三个重要部分组成：

- 核心语言：提供了所有构件块，包括变量、数据类型和常量，等等
- C++标准库：提供了大量的函数，用于操作文件、字符串等
- 标准模板库(STL)：提供了大量的方法，用于操作数据结构等





## 2 基本语法

### 2.1 简单程序

通过一个简单的c++程序进行介绍

```c++
#include <iostream>		//头文件
using namespace std;	//命名空间：一种封装标识符的机制，用于防止命名冲突

int main(){		//主函数：程序开始执行的地方
	cout << "hello world";
    return 0;	//返回值：int类型，程序执行成功默认返回值为0
}
```

1. 头文件：程序预先需要使用的文件，里面包含了在之后的编码中要用到的类和函数

   > 头文件类型：
   >
   > 1.标准库头文件
   >
   > ```cpp
   > #include <iostream>
   > ```
   >
   > 2.自定义头文件
   >
   > ```cpp
   > #include "my_custom_header.h"
   > ```
   >
   > 3.第三方库头文件
   >
   > ```cpp
   > #include <vector>
   > ```



### 2.2 注释

注释：给程序员看的备注和说明，用于提高代码的可读性和可维护性，编译器会忽略注释

1. 单行注释

   ```cpp
   // 这是单行注释，用于注释一行代码
   ```

2. 多行注释

   ```cpp
   /*	这是多行注释
   	用于注释多行代码
   */	
   ```

   

### 2.3 语句

语句：构成程序的基本单位，表示执行的单个操作或指令，以分号`;`作为语句结束符

> 注意：语句以;号结尾，不是换行
>
> ```cpp
> //例如
> std::cout << "hello world";
> return 0;
> 
> std::cout
> << "hello world"
> ;
> return
> 0
> ;
> 
> std::cout << "hello world"; return 0;
> //这三种写法都不会报错，只是第一种更易读，输出结果都一样
> ```

语句块：用`{}`包裹的多个语句

```cpp
{
    std::cout << "hello world";
    std::cout << "this is cpp node"
}
```



### 2.4 C++程序代码组成

1. 预处理指令

   这些指令在编译前由预处理器处理，常见预处理指令`#include`用于包含头文件，以及`#define`用于定义宏

   ```cpp
   #include <iostream>
   #define PI 3.14159
   ```

2. 注释：用于解释代码，提高可读性，不参与编译

   ```cpp
   // 这是单行注释
   
   /*	这是
   	多行
   	注释
   */
   ```

3. 函数：执行特定任务的代码块，每个c++程序有且只有一个main函数作为程序的入口

   ```cpp
   int main(){
       return 0;
   }
   ```

4. 变量和数据类型：变量是数据的存储位置，不同的数据类型，存储的格式不同，解释也不一样

   ```cpp
   int number;
   double price;
   ```

5. 表达式和运输符：表达式由变量，常量、运算符组成，用于计算值

   ```cpp
   int sum = a + b;
   bool isEqual = (a == b);
   ```

6. 控制流语句：控制程序执行的顺序，包括条件语句(if、switch)和循环语句(for、while)

   ```cpp
   if(condition){
       //代码
   }
   
   for(int i = 1; i < 10; i++){
       //循环代码
   }
   ```

7. 类和对象：类是定义对象属性和行为的模板，对象是类的实例

   ```cpp
   class myClass{
       //类定义
   }
   
   myClass obj;	//创建类实例
   ```

8. 错误处理：处理异常的机制，`try`、`catch`、`throw`都用于错误处理

   ```cpp
   try{
       //可能抛出异常的代码
   }
   
   catch(exception& e){
       //异常处理
   }
   ```

9. 模板(泛编程)：用于创建泛型类或函数

   ```cpp
   template <typename T>
   T max(T x, T y) {
       return (x > y) ? x : y;
   }
   ```

10. 命名空间：用于组织代码，防止命名冲突

    ```cpp
    namespace myNamespace {
        //代码
    }
    ```




## 3 数据类型

数据类型分类：基本数据类型、复合数据类型、自定义数据类型、特殊数据类型

```objective-c
C++ 数据类型
├─ 基本数据类型
│  ├─ 整型
│  │  ├─ int
│  │  ├─ short
│  │  ├─ long
│  │  └─ long long
│  ├─ 浮点型
│  │  ├─ float
│  │  └─ double
│  ├─ 字符型
│  │  └─ char
│  ├─ 布尔型
│  │  └─ bool
│  └─ 空类型
│     └─ void
│
├─ 复合数据类型
│  ├─ 数组
│  ├─ 结构体 (struct)
│  ├─ 联合体 (union)
│  └─ 枚举类型 (enum)
│
├─ 指针类型
│  └─ 指向各类数据类型的指针
│
├─ 引用类型
│  └─ 引用各类数据类型
│
├─ 用户定义类型
│  └─ 类 (class)
│
├─ 函数类型
│  └─ 函数签名 (返回类型和参数类型)
│
└─ 枚举类类型
   └─ enum class
```



### 3.1 基本数据类型

| 数据类型      | 描述                                       | 大小(典型)                   | 存储标准(转为二进制规则)      |
| ------------- | ------------------------------------------ | ---------------------------- | ----------------------------- |
| `int`         | 整型，用于存储整数                         | 4字节                        | 补码系统                      |
| `short`       | 短整型，比整型小的整数类型                 | 2字节                        | 补码系统                      |
| `long`        | 长整型，比整型大的整数类型                 | 4字节(或8字节)               | 补码系统                      |
| `long long`   | 比`long`还大的整数类型                     | 8字节                        | 补码系统                      |
|               |                                            |                              |                               |
| `float`       | 单精度浮点数，用于存储小数                 | 4字节                        | IEEE754标准                   |
| `double`      | 双精度浮点数，用于存储大数和精度更高的小数 | 8字节                        | IEEE754标准                   |
| `long double` | 长双精度型                                 | 8字节(Windows) 16字节(Linux) | IEEE754标准                   |
|               |                                            |                              |                               |
| `char`        | 字符型，用于存储单个字符                   | 1字节                        | ASCLL编码                     |
| `wchar_t`     | 宽字符类型，用于存储单个字符               | 2字节(Windows) 4字节(Linux)  | UTF-16(Windows) UTF-32(Linux) |
| `char16_t`    | C++11 引入的字符类型                       | 2字节                        | UTF-16                        |
| `char32_t`    | C++11 引入的字符类型                       | 4字节                        | UTF-32                        |
|               |                                            |                              |                               |
| `bool`        | 布尔型，用于存储`true`和`false`            | 1字节                        | 1(true) 0(false)              |
| `void`        | 空类型，通常用于指定无返回值的函数         | 无                           | 无                            |

> 整数类型还有`signed`，`unsigned`修饰符，表述有符号和无符号位，实际上`long`，`short`也是修饰符



### 3.2 复合数据类型

复合数据类型：有基本数据类型构成的更加复杂的数据结构

| 数据类型         | 描述                                                         |
| ---------------- | ------------------------------------------------------------ |
| 数组             | 相同类型数据的元素组合，存储在连续的内存位置                 |
| 结构体(`struct`) | 不同类型数据项的集合，每个数据项被称为成员                   |
| 联合(`union`)    | 联合允许在同一内存位置存储不同数据类型的数据，但是任一时刻只能存储其中一种类型的数据 |
| 类(`class`)      | 类是面向对象编程的基础，包含数据成员和函数成员               |
| 枚举(`enum`)     | 一种用户定义的类型，由一组命名的整型常量组成                 |
| 指针             | 存储内存地址的变量，可以指向某个类型的数据                   |
| 引用             | 变量的别名，给已经存在的变量起一个别名                       |
| 函数             | 函数也可以视为一种复合数据类型，因为可以接受参数并由返回值   |



### 3.3 非内置数据类型

| 数据类型    | 描述                  |
| ----------- | --------------------- |
| std::string | 字符串数据类型(UTF-8) |
| 模板类型    |                       |



## 4 字面值常量

字面值常量：指直接出现在代码中的固定值，这些值本身是不可变的。字面值常量可以是数字、字符、字符串的等基本数据类型的直接表示

> 注意：字面值常量也是具有数据类型的

### 4.1 整数字面值

| 前缀                            | 含义       | 示例      |
| ------------------------------- | ---------- | --------- |
| 无                              | 默认十进制 | `30`      |
| `0`(数字零)                     | 八进制     | `036`     |
| `0x`或`0X`(数字零和大小写字母x) | 十六进制   | `0x1e`    |
| `0b`或`0B`(数字零和大小写字母b) | 二进制     | `0b11110` |

| 后缀       | 含义            | 实例   |
| ---------- | --------------- | ------ |
| 无         | 默认位`int`类型 | `30`   |
| `u`或`U`   | `unsigned`类型  | `30u`  |
| `l`或`L`   | `long`类型      | `30L`  |
| `ll`或`LL` | `long long`类型 | `30LL` |

> 注意：
>
> ​    前缀用于指定整数的基数(进制)
>
> ​    后缀用于指定整数的类型和大小



### 4.2 浮点字面值

| 后缀     | 含义              | 示例    |
| -------- | ----------------- | ------- |
| 无       | 默认`double`类型  | `3.14`  |
| `f`或`F` | `float`类型       | `3.14f` |
| `l`或`L` | `long double`类型 | `3.14L` |

> 注意：与整数字面值不同，浮点型字面值没有用于指示类型的前缀



### 4.3 字符字面值

**单引号**括起来的**表示单个字符**的字面值。

| 类型        | 描述                                                         | 示例                                                         |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 普通字符    | 直接表示的单个字符                                           | `'s'`、`'8'`、`'?'`                                          |
| 转义序列    | 使用反斜杠 `\` 开头的特殊字符序列，用于表示无法直接表示或有特殊意义的字符 | `\n`(换行)、`\t`(水平制表符)、`\\`(反斜杠本身)、`\'`(单引号)<br/>`\"`(双引号)、`\0`(空字符)、`\b`(退格符)、`\r`(回车符) |
| Unicode字符 | `char16_t`: 使用`u`前缀，UTF-16编码。<br>`char32_t`: 使用`U`前缀，UTF-16编码 | `u'你'`(UTF-16)，`U'你'`(UTF-32)                             |
| 宽字符      | 使用`L`前缀表示的宽字符，Windows(UTF-16)，Linux(UTF-32)      | `L'好'`                                                      |

补充转义序列

| 转义序列     | 描述                                                         | 示例         |
| ------------ | ------------------------------------------------------------ | ------------ |
| `\nnn`       | 使用**八进制**数表示单个字符(ASCLL字符集，`nnn`表示1~3个八进制数) | `\44`        |
| `\xnn`       | 使用**十六进制**数表示单个字符(ASCLL字符集，`nn`表示1~2个十六进制数) | `\x24`       |
| `\unnnn`     | Unicode 字符（UTF-16，`nnnn` 是4个**十六进制**数字，C++11 新增） | `\u0024`     |
| `\Unnnnnnnn` | Unicode 字符（UTF-32，`nnnnnnnn` 是8个**十六进制**数字，C++11 新增） | `\U00000024` |



### 4.4 字符串字面值

字符串字面值：由双引号`""`包裹的字符序列

| 类型          | 前缀 | 示例                | 描述                                                 |
| ------------- | ---- | ------------------- | ---------------------------------------------------- |
| 普通字符串    | 无   | `"Hello, world"`    | 标准的字符数组，以空字符结尾(ASCLL字符集)            |
| 宽字符串      | `L`  | `L"宽字符串"`       | 宽字符数组，通常用于 Unicode 文本                    |
| UTF-8 字符串  | `u8` | `u8"你好"`          | UTF-8 编码的字符串字面值                             |
| UTF-16 字符串 | `u`  | `u"你好"`           | UTF-16 编码的字符串字面值                            |
| UTF-32 字符串 | `U`  | `U"你好"`           | UTF-32 编码的字符串字面值                            |
| 原始字符串    | `R`  | `R"(原始\n字符串)"` | 允许包含转义字符的原始字符串，即不对转义字符进行转义 |



### 4.5 布尔字面值

布尔字面值：只有两个值，`true`和`false`

| 特性     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 数据类型 | `bool`                                                       |
| 字面值   | `true`, `false`                                              |
| 意义     | `true` 表示逻辑真（等价于整数 `1`）<br>`false` 表示逻辑假（等价于整数 `0`） |
| 使用场景 | 条件判断、逻辑表达式、函数返回值                             |
| 整数转换 | `true` 转换为 `1`<br>`false` 转换为 `0`                      |
| 逆向转换 | 非零整数转换为 `true`<br>零值转换为 `false`                  |

### 4.6 空指针字面值

空指针字面值：用于表示一个不指向任何对象的指针

| 空指针字面值 | 类型        | 描述                              | 用途                                     | 示例                  |
| ------------ | ----------- | --------------------------------- | ---------------------------------------- | --------------------- |
| `NULL`       | 依赖于实现  | 在 C++11 之前用作空指针的标准表示 | 表示不指向任何对象的指针                 | `int* ptr = NULL;`    |
| `nullptr`    | `nullptr_t` | C++11 引入的空指针字面值          | 表示不指向任何对象的指针，提高类型安全性 | `int* ptr = nullptr;` |

> - **类型安全**：`NULL` 本质上是整数 `0`，可能会导致类型混淆和错误，尤其是在函数重载的场景中。`nullptr` 作为一个特殊的类型，能够避免这类问题。
> - **清晰语义**：`nullptr` 明确表示空指针，使代码更易于理解。

### 4.7 自定义字面值



## 5 变量

变量：在C++中，变量代表了内存中某个位置的数据

### 5.1 变量声明

变量声明：告诉编译器变量的类型和名称，但是不为其分配内存空间

语法：

- 声明变量但不定义：`extern 变量类型 变量名`
- 声明变量并定义：`变量类型 变量名`

```cpp
// 声明变量但不定义
extern int num;

// 声明变量并定义
int num;
```

> 注意：
>
> - C++程序中变量可以多次声明，但是只能定义一次
> - 仅仅声明变量不会为其分配内存
> - 声明并定义变量会为其分配内存
> - 在全局变量的情况下，可以在一个文件中使用 `extern` 关键字来声明变量，而在另一个文件中定义它。



### 5.2 变量定义

变量定义：告诉编译器变量的类型和名称，并为其分配内存空间

语法：`变量类型 变量名`

```cpp
//变量定义
int num;
```



### 5.3 变量初始化

变量初始化：定义变量的同时给变量赋值，被称为变量的初始化

1. **直接初始化**

- **语法**：`类型 变量(值)`
- **作用**：使用括号内的值，来初始化变量
- **示例**

```cpp
int num(10);
```



2. **赋值初始化**

- **语法**：`类型 变量 = 值`
- **作用**：使用等号右侧的值，来初始化变量
- **示例**

```cpp
char ch = 'a';
```



3. **列表初始化**

- **语法**：`类型 变量{值}`
- **作用**：使用花括号内的值，来初始化变量，并防止数据丢失(窄化转化)
- **示例**

```cpp
int number{10};
```

> 窄化转化：
>
> - **从浮点数到整数的转换**：
>   - 浮点数可能包含小数部分，转换为整数时，小数部分会被丢弃，例如，从 `3.14` 转换为 `3`。
> - **从大整数类型到小整数类型的转换**：
>   - 如果一个大的整数值（如 `long long`）无法完整地被存储在一个小的整数类型（如 `int`）中，这种转换可能导致数据丢失或溢出。
> - **从整数类型到布尔类型的转换**：
>   - 任何非零整数在转换为布尔类型时都会变成 `true`，零变成 `false`。
> - **从大范围浮点数到小范围浮点数的转换**：
>   - 如从 `double` 类型到 `float` 类型的转换可能导致精度损失。
>
> 
>
> ### C++11 列表初始化防止窄化转换
>
> 使用 `{}` 进行列表初始化时，C++11 会检查是否存在窄化转换：
>
> - **如果有窄化转换**：编译器会拒绝这种初始化，编译过程中会报错。
> - 示例
>   - `int x{7.9};` // 错误：浮点数到整数的窄化转换
>   - `char y{300};` // 错误：超出 `char` 范围的窄化转换



4. **值初始化**

- **语法**：`类型 变量{}`
- **作用**：对基本类型变量进行零初始化，对类类型变量调用默认构造函数
- **示例**

```cpp
int e{}; // 初始化为 0
double f{}; // 初始化为 0.0
```



5. **聚合初始化**

- **语法**：适用于数组和结构体，使用花括号 `{}` 包围初始值列表。
- **作用**：初始化数组元素或结构体成员。
- **示例**

```cpp
int arr[3]{1, 2, 3};
struct Point { int x; int y; } p{10, 20};
```



6. **构造函数初始化(对于类对象)**

- **语法**：`类名 变量名(参数列表);`
- **作用**：调用类的构造函数来初始化类对象。
- **示例**

```cpp
std::string str("Hello, Constructor");
std::vector<int> vec(10, 0); // 10个元素，每个都是0
```





### 5.4 命名规则

在C++中，变量的命名遵循着一定的规则，这些规则确保了代码的可读性和一致性

1. **字符集**

- 变量名只能包含字母（`a-z`，`A-Z`）、数字（`0-9`）和下划线（`_`）。
- 变量名必须以字母或下划线开头。不能以数字开头。



2. **区分大小写**

- C++ 是区分大小写的语言。因此，`myVar`、`myvar` 和 `MYVAR` 是三个不同的变量。



3. **关键字保留**

- 不能使用 C++ 的关键字作为变量名，如 `int`, `double`, `return`, `if` 等

> ### 最佳实践
>
> 1. **有意义的命名**：
>    - 使用描述性的名称来命名变量，使其能够清晰地表达变量的用途或意图，如 `userAge`, `totalSum`。
> 2. **命名风格**：
>    - **驼峰命名法**（CamelCase）：每个单词的首字母大写，除了第一个单词，如 `studentName`。
>    - **下划线命名法**（snake_case）：单词之间使用下划线分隔，全部小写，如 `student_name`。
> 3. **避免使用单个字符**：
>    - 除了在循环或临时变量中，避免使用像 `i`, `j`, `k` 这样的单个字符作为变量名。
> 4. **常量命名**：
>    - 常量通常使用全大写字母，单词之间用下划线分隔，如 `MAX_COUNT`。
> 5. **避免缩写**：
>    - 除非缩写非常常见和明确（如 `info` 代表 `information`），否则尽量避免使用缩写。
>
> **示例：**
>
> ```cpp
> int itemCount;          // 驼峰命名
> double shipping_cost;   // 下划线命名
> const int MAX_ITEMS = 100; // 常量命名
> ```



### 5.5 作用域

变量作用域：定义了变量在程序中的**可见性**和**生命周期**，根据变量定义的位置和方式，可以将变量的作用域分为以下几种



1. **局部作用域**（Local Scope）

- **定义**：在函数或代码块（如 `if`, `for`, `while` 块）内部定义的变量。
- **特点**
  - 变量只在定义它的函数或代码块内部可见。
  - 当控制流离开该函数或代码块时，这些变量将被销毁。



2. **全局作用域**（Global Scope）

- **定义**：在所有函数之外定义的变量。
- **特点**
  - 全局变量在整个程序的任何部分都是可见的，从定义点开始到程序结束。
  - 全局变量的生命周期贯穿整个程序。



3. **文件作用域**（File Scope）

- **定义**：使用 `static` 关键字在文件级别定义的变量。
- **特点**
  - 这些变量在整个文件中都是可见的，但不能被其他文件访问。



4. **类作用域**（Class Scope）

- **定义**：在类定义内部定义的变量（即类的成员变量）。
- **特点**
  - 成员变量在整个类中都是可见的，并且它们的生命周期与类的对象实例相关联。



5. **命名空间作用域**（Namespace Scope）

- **定义**：在命名空间内定义的变量。
- **特点**
  - 这些变量在声明它们的命名空间内是可见的，并且可以通过适当的命名空间限定符在其他地方访问。



**示例**

```cpp
#include <iostream>

int globalVar; // 全局变量

void function() {
    int localVar; // 局部变量
    static int staticVar; // 具有文件作用域的静态变量
}

class MyClass {
public:
    int memberVar; // 类作用域
};

namespace MyNamespace {
    int namespaceVar; // 命名空间作用域
}

int main() {
    // 使用 globalVar, localVar 不可见
    return 0;
}
```



### 5.6 常量

| 常量类型         | 描述                                 | 示例                               |
| ---------------- | ------------------------------------ | ---------------------------------- |
| 字面量常量       | 直接表示值本身的常量                 | `5`, `3.14`, `'a'`                 |
| `const` 常量     | 使用 `const` 关键字声明的不可变变量  | `const int MAX_SIZE = 100;`        |
| 枚举常量         | 用户定义的包含一组命名整型常量的类型 | `enum Color { RED, GREEN, BLUE };` |
| 宏常量(不推荐)   | 使用预处理器 `#define` 定义的常量    | `#define PI 3.14159`               |
| `constexpr` 常量 | C++11 引入的编译时常量               | `constexpr int SQUARE = 10 * 10;`  |

> - 对于需要在编译时确定值的场合，使用 `constexpr`。
> - 对于运行时不变的值，使用 `const`。
> - 避免使用宏常量（`#define`），因为它们不受类型检查的约束，可能导致不可预期的错误。
> - `const` 常量必须在声明时初始化，因为之后不能更改它们的值。
> - 有一个普遍的约定是将全局常量和宏常量的名字全部大写，以区分它们与普通变量和局部常量。



## 6 类型转换

类型转换是一个重要概念，它允许在不同的数据类型之间转换值。C++ 提供了几种类型转换机制，每种机制都有其用途和注意事项。

### 6.1 显式类型转换

1. **C 风格类型转换**：
   - 语法：`(类型)表达式`
   - 示例：`int x = (int)3.14;`
   - 注意事项：不推荐使用，因为它不够安全和明确。
2. **`static_cast`**：
   - 语法：`static_cast<类型>(表达式)`
   - 用途：用于非多态类型的转换。
   - 示例：`double y = static_cast<double>(x);`
3. **`dynamic_cast`**：
   - 语法：`dynamic_cast<类型>(表达式)`
   - 用途：主要用于处理具有多态性的对象。
   - 示例：`Base* b = dynamic_cast<Base*>(d);`（其中 `d` 是派生类的指针）
4. **`const_cast`**：
   - 语法：`const_cast<类型>(表达式)`
   - 用途：用于修改类型的 `const` 或 `volatile` 属性。
   - 示例：`const int* pci = const_cast<int*>(&ci);`
5. **`reinterpret_cast`**：
   - 语法：`reinterpret_cast<类型>(表达式)`
   - 用途：用于位级别的重新解释。
   - 示例：`int* ip = reinterpret_cast<int*>(fp);`（其中 `fp` 是一个浮点数的指针）



### 6.2 隐式类型转换

| 特点                                 | 常见场景                                 | 示例                                                         |
| ------------------------------------ | ---------------------------------------- | ------------------------------------------------------------ |
| 自动进行，可能导致数据丢失或意外行为 | 算术运算、函数调用、赋值                 | `int i = 5; double d = 2.5; double result = i * d; // i 被隐式转换为 double` |
| 编译器自动执行，无需程序员显式指定   | 混合不同类型的表达式，传递函数参数       | `void func(double x); int num = 10; func(num); // num 被隐式转换为 double` |
| 便利性和风险并存                     | 将一种类型的表达式赋值给另一种类型的变量 | `double pi = 3.14; int a = pi; // pi 被隐式转换为 int`       |



## 7 运算符

在 C++ 中，运算符是用于执行特定操作的符号或关键字。

### 7.1 算术运算符

| 运算符 | 作用                     | 示例                             |
| ------ | ------------------------ | -------------------------------- |
| `+`    | 合并两个数值。           | `int sum = 5 + 3; // sum = 8`    |
| `-`    | 从一个数中减去另一个数。 | `int diff = 5 - 3; // diff = 2`  |
| `*`    | 将两个数相乘。           | `int prod = 5 * 3; // prod = 15` |
| `/`    | 将一个数除以另一个数。   | `int quot = 10 / 2; // quot = 5` |
| `%`    | 返回两个数相除的余数。   | `int rem = 5 % 2; // rem = 1`    |



### 7.2 关系运算符

| 运算符 | 作用                               | 示例                                                         |
| ------ | ---------------------------------- | ------------------------------------------------------------ |
| `==`   | 比较两个值是否相等。               | `bool isEqual = (5 == 3); // isEqual = false`                |
| `!=`   | 比较两个值是否不相等。             | `bool isNotEqual = (5 != 3); // isNotEqual = true`           |
| `<`    | 检查一个值是否小于另一个值。       | `bool isLess = (5 < 3); // isLess = false`                   |
| `>`    | 检查一个值是否大于另一个值。       | `bool isGreater = (5 > 3); // isGreater = true`              |
| `<=`   | 检查一个值是否小于或等于另一个值。 | `bool isLessOrEqual = (5 <= 5); // isLessOrEqual = true`     |
| `>=`   | 检查一个值是否大于或等于另一个值。 | `bool isGreaterOrEqual = (5 >= 3); // isGreaterOrEqual = true` |



### 7.3 逻辑运算符

| 运算符 | 作用                                         | 示例                                                   |
| ------ | -------------------------------------------- | ------------------------------------------------------ |
| `&&`   | 如果两个操作数都为真，则结果为真。           | `bool result = (5 > 3) && (2 < 3); // result = true`   |
| `\|\|` | 如果两个操作数中至少有一个为真，则结果为真。 | `bool result = (5 < 3) \|\| (2 < 3); // result = true` |
| `!`    | 取反操作数的布尔值。                         | `bool result = !(5 < 3); // result = true`             |



### 7.4 赋值运算符

| 运算符 | 作用                                                     | 示例                   |
| ------ | -------------------------------------------------------- | ---------------------- |
| `=`    | 将右侧操作数的值赋给左侧操作数。                         | `int a = 5; // a = 5`  |
| `+=`   | 将左侧操作数与右侧操作数相加，然后将结果赋给左侧操作数。 | `a += 2; // a = a + 2` |
| `-=`   | 从左侧操作数中减去右侧操作数，然后将结果赋给左侧操作数。 | `a -= 2; // a = a - 2` |
| `*=`   | 将左侧操作数与右侧操作数相乘，然后将结果赋给左侧操作数。 | `a *= 2; // a = a * 2` |
| `/=`   | 将左侧操作数除以右侧操作数，然后将结果赋给左侧操作数。   | `a /= 2; // a = a / 2` |
| `%=`   | 将左侧操作数对右侧操作数取模，然后将结果赋给左侧操作数。 | `a %= 2; // a = a % 2` |



### 7.5 递增和递减

| 运算符 | 作用                                                         | 示例                       |
| ------ | ------------------------------------------------------------ | -------------------------- |
| `++`   | 增加变量的值。前缀形式（`++a`）先增加再返回值，后缀形式（`a++`）先返回值再增加。 | `int a = 5; a++; // a = 6` |
| `--`   | 减少变量的值。前缀形式（`--a`）先减少再返回值，后缀形式（`a--`）先返回值再减少。 | `int a = 5; a--; // a = 4` |



### 7.6 位运算符

| 运算符 | 作用                                   | 示例                                  |
| ------ | -------------------------------------- | ------------------------------------- |
| `&`    | 对两个数的二进制位执行逐位与操作。     | `int result = 5 & 3; // result = 1`   |
| `\|`   | 对两个数的二进制位执行逐位或操作。     | `int result = 5 \| 3; // result = 7`  |
| `^`    | 对两个数的二进制位执行逐位异或操作。   | `int result = 5 ^ 3; // result = 6`   |
| `~`    | 对一个数的二进制位执行逐位取反操作。   | `int result = ~5; // result = -6`     |
| `<<`   | 将一个数的二进制位向左移动指定的位数。 | `int result = 5 << 1; // result = 10` |
| `>>`   | 将一个数的二进制位向右移动指定的位数。 | `int result = 5 >> 1; // result = 2`  |



### 7.7 三元运算符

| 运算符 | 作用                                       | 示例                                                         |
| ------ | ------------------------------------------ | ------------------------------------------------------------ |
| `?:`   | 根据条件表达式的真值，选择两个值中的一个。 | `int result = (a > b) ? a : b; // 如果 a > b，result = a，否则 result = b` |



### 7.8 类型转换

| 运算符             | 作用                                        | 示例                                                         |
| ------------------ | ------------------------------------------- | ------------------------------------------------------------ |
| `static_cast`      | 用于非多态类型的转换。                      | `double pi = 3.14159; int n = static_cast<int>(pi); // n = 3` |
| `dynamic_cast`     | 用于多态类型的安全转换。                    | `Base* b = dynamic_cast<Base*>(d); // d 是派生类的指针`      |
| `const_cast`       | 用于修改类型的 `const` 或 `volatile` 属性。 | `const int* pci; int* pi = const_cast<int*>(pci);`           |
| `reinterpret_cast` | 用于不同类型之间的低级转换。                | `long p; int* ip = reinterpret_cast<int*>(&p);`              |



### 7.9 优先级

| 优先级 | 运算符                       | 结合律 | 描述             |
| ------ | ---------------------------- | ------ | ---------------- |
| 1      | `::`                         | 左到右 | 作用域解析运算符 |
| 2      | `++` `--` (后缀)             | 左到右 | 后缀递增/递减    |
| 2      | `()`                         | 左到右 | 函数调用         |
| 2      | `[]`                         | 左到右 | 数组下标         |
| 2      | `.` `->`                     | 左到右 | 成员访问         |
| 2      | `typeid`                     | 左到右 | 类型信息         |
| 3      | `++` `--` (前缀)             | 右到左 | 前缀递增/递减    |
| 3      | `+` `-` `!` `~`              | 右到左 | 一元运算符       |
| 3      | `static_cast` `dynamic_cast` | 右到左 | 类型转换运算符   |
| 3      | `sizeof` `alignof`           | 右到左 | 大小与对齐       |
| 4      | `*` `/` `%`                  | 左到右 | 乘法/除法/取模   |
| 5      | `+` `-`                      | 左到右 | 加法/减法        |
| 6      | `<<` `>>`                    | 左到右 | 位移运算符       |
| 7      | `<` `<=` `>` `>=`            | 左到右 | 关系运算符       |
| 8      | `==` `!=`                    | 左到右 | 相等性运算符     |
| 9      | `&`                          | 左到右 | 按位与           |
| 10     | `^`                          | 左到右 | 按位异或         |
| 11     | `\|`                         | 左到右 | 按位或           |
| 12     | `&&`                         | 左到右 | 逻辑与           |
| 13     | `\|\|`                       | 左到右 | 逻辑或           |
| 14     | `?:`                         | 右到左 | 三元条件运算符   |
| 15     | `=` `+=` `-=` `*=` `/=` `%=` | 右到左 | 赋值运算符       |
| 15     | `<<=` `>>=` `&=` `^=` `\|=`  | 右到左 | 复合赋值运算符   |
| 16     | `,`                          | 左到右 | 逗号运算符       |

> 简而言之：一元运算符 > 二元运算符 > 三元运算符 > 赋值运算符



## 8 语句

在C++中，语句是构成程序的基本单位，用于表达特定的操作或逻辑。

### 8.1 表达式语句

| **特性**     | **描述**                                                     |
| ------------ | ------------------------------------------------------------ |
| 定义         | 由一个表达式和一个终止的分号构成。用于计算表达式并标记语句结束。 |
| 表达式的类型 | - 赋值表达式（例如 `a = 5;`）<br>- 算术运算（例如 `a + b;`）<br>- 函数调用（例如 `print("Hello");`）<br>- 递增或递减操作（例如 `counter++;`）<br>- 逻辑运算（例如 `a && b;`） |
| 作用         | 改变程序状态，例如修改变量的值或调用函数。                   |
| 分号的重要性 | 分号是区分不同语句的关键，表示一个表达式的结束。             |
| 空表达式语句 | 只包含一个分号的语句（`；`），不执行任何操作，有时用于循环体中。 |
| 使用场景     | 在循环、条件语句中更新或检查变量，以及在函数调用中常见。     |



### 8.2 复合语句

复合语句（也称为块语句）是一种重要的语句结构，用于将多个语句组合成一个单一的执行块。

| **特性**         | **描述**                                                     |
| ---------------- | ------------------------------------------------------------ |
| 定义和结构       | 由一对大括号 `{}` 包围，内部可以包含多个语句。               |
| 作用域           | 复合语句内声明的变量只在大括号内部可见和可用，提供块级作用域。 |
| 用途             | - 控制流结构（如`if`、`for`、`while`）中的代码块<br>- 函数体<br>- 创建局部作用域 |
| 初始化和清理     | 进入复合语句时执行变量声明和初始化，离开时销毁自动存储期的变量。 |
| 与控制结构的结合 | 允许在条件判断或循环迭代中执行多个语句。                     |
| 空复合语句       | 不包含任何语句的复合语句（`{}`）是合法的，有时用于语法要求但逻辑不需要执行任何操作的场合。 |
| 异常处理         | 可以包含异常处理结构（如`try-catch`块），用于处理块内发生的异常。 |



### 8.3 条件语句

**条件控制语句**：作用是根据给定的条件来决定程序的执行路径。

1. **if语句**

```cpp
if (表达式1) {
    // 表达式1为真，则执行
} else if (表达式2) {
    // 表达式2为真，则执行
} else {
    // 表达式1、2都为假，则执行
}
```

> **注意：**在C++中，任何非零的数值或非空的指针都被视为`true`，而零值或空（`nullptr`）指针被视为`false`。



2. **switch语句**

**语法：**

```cpp
switch (expression) {
    case value1:
        // 代码块1
        break;	//可选
    case value2:
        // 代码块2
        break;	//可选
    // 更多 case...
    default:
        // 默认代码块
}
```

**示例：**

```cpp
#include <iostream>
#include <cctype>  // 用于字符转换函数

int main() {
    std::cout << "请输入成绩等级（A、B、C、D）: ";
    char str = std::cin.get();
    str = std::toupper(str);  // 将输入转换为大写字母

    switch (str) {
        case 'A':
            std::cout << "优秀";
            break;
        case 'B':
            std::cout << "良好";
            break;
        case 'C':
            std::cout << "及格";
            break;
        case 'D':
            std::cout << "仍需努力";
            break;
        default:
            std::cout << "无效输入。请输入 A、B、C 或 D。";
    }

    return 0;
}
```

> 注意：
>
> - **switch** 语句中的 **expression** 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
> - 在一个 switch 中可以有任意数量的 case 语句。每个 case 后跟一个要比较的值和一个冒号。
> - case 的 **constant-expression** 必须与 switch 中的变量具有相同的数据类型，且必须是一个常量或字面量。
> - 当被测试的变量等于 case 中的常量时，case 后跟的语句将被执行，直到遇到 **break** 语句为止。
> - 当遇到 **break** 语句时，switch 终止，控制流将跳转到 switch 语句后的下一行。
> - 不是每一个 case 都需要包含 **break**。如果 case 语句不包含 **break**，控制流将会 *继续* 后续的 case，直到遇到 break 为止。
> - 一个 **switch** 语句可以有一个可选的 **default** case，出现在 switch 的结尾。default case 可用于在上面所有 case 都不为真时执行一个任务。default case 中的 **break** 语句不是必需的。



### 8.4 循环语句

在C++中，循环语句是用于重复执行一段代码直到满足特定条件的关键结构。

1. **`for循环`**

**语法**

```cpp
for (initialization; condition; increment) {
    // 循环体
}
```

> **执行顺序**
>
> 1. **初始化表达式**：循环开始前执行一次。
> 2. **条件表达式**：在每次循环开始前检查。如果条件为真，执行循环体；如果为假，循环终止。
> 3. **循环体**：如果条件为真，执行循环体内的语句。
> 4. **增量表达式**：循环体内的语句执行完毕后，增量表达式执行。
> 5. 返回第2步，直到条件表达式为假。

**示例**

```cpp
for (int i = 0; i < 5; i++) {
    std::cout << i << " ";
}
```



2. **`while循环`**

**语法**

```cpp
while (condition) {
    // 循环体
}
```

> **执行顺序**
>
> 1. **条件检查**：在每次循环的开始，首先检查条件表达式。
>    - 如果条件表达式的结果为`true`（非零），则继续执行循环。
>    - 如果条件表达式的结果为`false`（零），则跳出循环，继续执行循环之后的代码。
> 2. **执行循环体**：如果条件为`true`，执行循环体内的语句。
> 3. **回到步骤1**：循环体执行完后，再次回到第一步，重新检查条件表达式。
>
> 循环会继续这个过程，直到条件表达式的结果为`false`。

**示例**

```cpp
int i = 0;
while (i < 5) {
    std::cout << i << " ";
    i++;  // 修改循环变量，确保循环最终能够结束
}
```



3. **`do-while循环`**

**语法**

```cpp
do {
    // 循环体
} while (condition);
```

> **执行顺序**
>
> 1. **执行循环体**：首先执行循环体内的语句。
> 2. **条件检查**：在循环体执行之后检查条件表达式。
>    - 如果条件为`true`，重复循环。
>    - 如果条件为`false`，结束循环，执行循环之后的代码。

**示例**

```cpp
int count = 0;
do {
    std::cout << "执行循环体" << std::endl;
    count++;
} while (count < 5);
```



### 8.5 跳转语句

| 跳转语句   | 用途                         | 示例                           | 特点                                                         |
| ---------- | ---------------------------- | ------------------------------ | ------------------------------------------------------------ |
| `break`    | 退出循环或`switch`语句       | `if (i == 5) break;`           | - 在循环或`switch`中使用<br>- 防止执行下一个`case`或继续循环 |
| `continue` | 跳过当前循环迭代的剩余部分   | `if (i == 5) continue;`        | - 只在循环内部使用<br>- 直接开始下一次迭代                   |
| `return`   | 从函数返回值并结束函数       | `return a + b;`                | - 适用于所有函数<br>- 无返回值函数中可用于提前退出           |
| `goto`     | 无条件跳转到同一函数内的标记 | `goto label; ... label: ... ;` | - 功能强大但不推荐<br>- 可导致代码结构混乱和难以维护         |



### 8.6 声明语句

| 类型           | 定义                         | 语法                                                         | 示例                                                     |
| -------------- | ---------------------------- | ------------------------------------------------------------ | -------------------------------------------------------- |
| 变量声明       | 指定变量的类型和名称         | `type identifier;`<br>`type identifier = value;`             | `int a;`<br>`double b = 3.14;`                           |
| 函数声明       | 指定函数的返回类型和参数列表 | `returnType functionName(parameterList);`                    | `void printMessage();`<br>`int add(int a, int b);`       |
| 类和结构体声明 | 定义一个新类型的结构或类     | `class ClassName {...};`<br>`struct StructName {...};`       | `class Car {...};`<br>`struct Point {...};`              |
| 类型别名声明   | 为现有类型创建新名称         | `using NewName = ExistingType;`<br>`typedef ExistingType NewName;` | `using IntPtr = int*;`<br>`typedef unsigned long ulong;` |
| 枚举声明       | 定义一个枚举类型             | `enum EnumName {value1, value2, ...};`                       | `enum Color {RED, GREEN, BLUE};`                         |
| 模板声明       | 定义类型安全的函数或类的模板 | `template <typename T> ...`                                  | `template <typename T> T getMax(T a, T b);`              |
| 命名空间声明   | 定义包含相关标识符的命名空间 | `namespace NamespaceName {...}`                              | `namespace MyNamespace {...}`                            |



### 8.7 空语句

| 特性         | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| **定义**     | 空语句仅包含一个分号（`;`），没有任何其他内容。              |
| **用途**     | 1. 作为循环结构中的占位符，当循环体不需要执行任何代码时。<br>2. 有条件的执行，当某些条件下不需要执行任何操作时。 |
| **示例**     | - 循环中的空语句：<br> `for (int i = 0; i < 100 && !found; i++) { if (array[i] == target) found = true; }`<br>- 条件语句中的空语句：<br> `if (condition) { ; } else { performAction(); }` |
| **注意事项** | - 避免误用：在不适当的地方使用可能导致逻辑错误。<br>- 代码清晰：尽量减少使用，以保持代码的可读性。 |
| **替代方案** | 尽可能使用更清晰的代码结构替代空语句，如条件语句或循环，以明确代码意图。 |



### 8.8 异常处理语句

| 语句       | 语法示例                                         | 描述                                                         | 用途                                                         | 示例用法                                                     |
| ---------- | ------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `try`      | `try { /* 代码块 */ }`                           | 定义一个尝试执行的代码块，其中的代码可能会抛出异常。         | 围绕可能抛出异常的代码，提供了一种尝试执行某些操作的方法。   | `try { /* 可能抛出异常的代码 */ }`                           |
| `catch`    | `catch (异常类型 异常处理器) { /* 处理代码 */ }` | 捕获由`try`块中抛出的特定类型的异常，并执行相应的处理代码。  | 处理`try`块中抛出的特定类型的异常。                          | `catch (const std::runtime_error& e) { /* 处理运行时错误 */ }`<br>`catch (...) { /* 处理所有类型的异常 */ }` |
| `throw`    | `throw 异常对象;`                                | 抛出一个异常对象。如果在`catch`块内部使用，则重新抛出当前异常。 | 在检测到异常情况时抛出异常，以供`catch`块捕获和处理。        | `throw std::runtime_error("错误发生");`<br>`throw; // 在catch块内重新抛出当前异常` |
| `noexcept` | `void functionName() noexcept;`                  | 指定函数不会抛出异常。用于函数声明或函数定义。               | 指示函数保证不抛出异常，有助于编译器优化和表明函数的异常安全性。 | `void myFunction() noexcept;`<br>`bool isSafe() noexcept(true);` |

> **语法规范：**
>
> - `try`块应该紧跟着那些可能抛出异常的代码。
> - 语法规范要求`try`块后必须至少有一个`catch`块。
> - `catch`块用于捕获和处理特定类型的异常。
> - 每个`catch`块只能捕获一种异常类型。如果需要处理多种类型的异常，应该使用多个`catch`块。
> - `catch`块应紧跟在`try`块之后。
> - 使用`catch (...)`可以捕获所有类型的异常，但应谨慎使用。
> - 使用`throw`关键字抛出异常。可以抛出任何类型的对象，但建议抛出继承自`std::exception`的对象。
> - 在`catch`块中使用裸`throw`语句可以重新抛出当前捕获的异常。
> - 自定义异常应该继承自`std::exception`或其派生类，并覆写`what()`方法。
> - 使用`noexcept`关键字指明函数不会抛出异常。
> - 确保`catch`块中的代码不会抛出异常，除非该异常将被另一个`catch`块捕获。
> - 在函数声明中使用`noexcept`关键字可以提高程序性能，因为编译器可以对不抛出异常的函数进行优化。

**示例：**

```cpp
#include <iostream>

int main() {

	try {
		throw 1;
	}
	catch (int) {
		std::cout << "程序出现异常";
		return 1;
	}

	std::cout << "程序运行正常";
	return 0;
}
```



## 9 小练习

用一些小练习巩固学习成果

### 9.1 判断质数

质数：质数（Prime Number）是大于1的自然数，它们的特点是只有两个正因数：1和它本身。换句话说，质数不能被除了1和它自身以外的任何正整数整除。

> 1. **定义**：质数是只有两个不同的正除数（1和它本身）的大于1的自然数。
> 2. **最小的质数**：最小的质数是2，它也是唯一的偶数质数。之后的质数是3、5、7、11、13等。
> 3. **无限性**：质数是无限的，也就是说，没有最大的质数。这是数论中的一个重要定理，由欧几里得首次证明。
> 4. **重要性**：质数在数论中扮演着核心角色。它们是整数环的基本构建块，因为每个大于1的整数都可以唯一地分解为质数的乘积（这被称为质因数分解）。
> 5. **检测质数**：确定一个给定的大整数是否为质数是计算上非常困难的问题，尤其是对于非常大的数。然而，这个问题对于密码学等领域非常重要。

**一个容易想到的写法：**

```cpp
#include <iostream>

bool isPrime(int number) {
	if (number == 1) {
		return false;
	}

	if (number == 2) {
		return true;
	}

	for (int i = 3; i < number; i++) {
		if (number % i == 0) {
			return false;
		}
	}

	return true;
}

int main() {

	//提示
	std::cout << "请输入一个正整数：";

	// 获取用户输入
	int number;
	std::cin >> number;
	bool result = isPrime(number);

	if (result) {
		std::cout << number << "是质数";
	}
	else
	{
		std::cout << number << "不是质数";
	}
}
```

**一个优化方案：**

```cpp
#include <iostream>

bool isPrime(int number) {
    if (number <= 1) {
        return false; // 小于等于1的数不是质数
    }
    if (number <= 3) {
        return true; // 2和3是质数
    }

    // 如果能被2或3整除，不是质数
    if (number % 2 == 0 || number % 3 == 0) {
        return false;
    }

    // 检查从5开始的所有数字，直到平方根
    for (int i = 5; i * i <= number; i += 6) {
        if (number % i == 0 || number % (i + 2) == 0) {
            return false;
        }
    }
    return true;
}

int main() {
    int number;
    std::cout << "请输入一个整数: ";
    std::cin >> number;

    if (std::cin.fail()) {
        std::cout << "输入无效，需要输入一个整数。" << std::endl;
        return 1; // 输入错误，返回1
    }

    if (isPrime(number)) {
        std::cout << number << " 是质数。" << std::endl;
    }
    else {
        std::cout << number << " 不是质数。" << std::endl;
    }

    return 0; // 程序正常结束
}
```





## 10 数组

**数组**是一种容器，用于存储固定数量的连续内存位置中的同类型元素。每个存储在数组中的元素可以通过数组索引（或数组下标）来访问，这个索引通常是从0开始的整数。

### 10.1 数组定义

1. **语法**

```cpp
ElementType arrayName[ArraySize];
```

> 其中：
>
> - `ElementType` 指定了数组中元素的类型。它可以是任何有效的C++数据类型，如 `int`、`float`、`double`、`char` 等。
> - `arrayName` 是你给数组指定的名称。
> - `ArraySize` 是一个整数，用于指定数组可以存储的元素数量。数组的大小必须是一个已知的常量表达式，因为它必须在编译时确定。



2. **描述**

- 数组是一组存储在连续内存位置的同类型元素。
- 数组中的每个元素都可以通过数组索引访问，索引从0开始。
- 数组的大小（即其中元素的数量）在声明时必须指定，并且在数组的整个生命周期中保持不变。
- 数组的元素默认初始化为其类型的默认值，比如 `int` 类型的元素默认为0。



3. **示例**

- **整数数组定义**

  ```cpp
   int myArray[5];
  ```

  这定义了一个名为 `myArray` 的数组，它可以存储5个整数。

- **初始化数组**：

  ```cpp
  cppCopy code
  int myArray[5] = {1, 2, 3, 4, 5};
  ```

  这定义了一个名为 `myArray` 的数组，并在定义时初始化了它的5个元素。

- **部分初始化**：

  ```cpp
  cppCopy code
  int myArray[5] = {1, 2};
  ```

  这定义了一个名为 `myArray` 的数组，只初始化了前两个元素，剩下的元素会自动初始化为0。

- **字符数组定义**：

  ```cpp
  cppCopy code
  char charArray[6] = {'H', 'e', 'l', 'l', 'o', '\0'};
  ```

  这定义了一个字符数组，用于存储字符串 "Hello"（包括结尾的空字符）。

- **浮点数数组定义**：

  ```cpp
  cppCopy code
  double doubleArray[3] = {1.5, 2.3, 3.6};
  ```

  这定义了一个名为 `doubleArray` 的数组，它包含3个 `double` 类型的浮点数。



> - **数组的声明**通常也隐含了定义，因为声明数组时，我们不仅告诉编译器数组的存在，同时也为数组元素分配了内存。例如，`int myArray[10];`这行代码既是声明也是定义，因为它为名为`myArray`的数组分配了10个整数的空间。
> - 如果我们仅仅想声明一个数组而不定义它（即不为它分配内存），我们通常会使用`extern`关键字。例如，`extern int myArray[];`这行代码仅仅声明了一个名为`myArray`的数组，但没有定义它（即没有分配内存）。这种情况通常出现在我们想在一个文件中声明一个数组，而该数组在另一个文件中被定义的情况。
>
> 在大多数情况下，当我们谈论数组时，我们实际上是在同时声明和定义它们。这是因为数组的大小必须在编译时已知，这使得数组的声明几乎总是伴随着内存的分配。因此，在实际使用中，数组的声明和定义这两个概念通常是混合在一起的。



### 10.2 数组初始化

1. **默认初始化**：

   - **语法**：`ElementType arrayName[ArraySize];`

   - **作用**：用于需要数组存储空间但初始值未知或稍后指定的情况。

   - **示例**：

     ```cpp
     int myArray[5];
     ```

   - **效果**：如果数组是自动存储（局部数组），元素具有未定义的值；如果是静态或全局数组，元素初始化为0。

   

2. **显式初始化**：

   - **语法**：`ElementType arrayName[ArraySize] = {element1, element2, ...};`

   - **作用**：在声明时为数组元素指定初始值。

   - **示例**：

     ```cpp
     int myArray[5] = {1, 2, 3, 4, 5};
     ```

   - **效果**：数组元素被初始化为指定的值。

   

3. **省略数组大小**：

   - **语法**：`ElementType arrayName[] = {element1, element2, ...};`

   - **作用**：让编译器根据提供的初始化元素数量自动确定数组的大小。

   - **示例**：

     ```cpp
     int myArray[] = {1, 2, 3, 4, 5};
     ```

   - **效果**：数组大小自动设置为提供的元素数量。

   

4. **字符数组的特殊情况**：

   - **语法**：`char arrayName[] = "StringLiteral";`

   - **作用**：简化字符数组的初始化，尤其用于存储字符串。

   - **示例**：

     ```cpp
     char myString[] = "Hello";
     ```

   - **效果**：自动包括终止空字符`\0`，使数组成为有效的C风格字符串。

   

5. **直接列表初始化**（自C++11起）：

   - **语法**：`ElementType arrayName[ArraySize]{element1, element2, ...};`

   - **作用**：提供一种更现代和一致的初始化方法。

   - **示例**：

     ```cpp
     int myArray[5]{1, 2, 3, 4, 5};
     ```

   - **效果**：与显式初始化类似，但使用了现代的初始化语法。

   

6. **不完全初始化**：

   - **语法**：`ElementType arrayName[ArraySize] = {element1, element2, ...};`

   - **作用**：初始化部分元素，其余元素自动初始化为默认值。

   - **示例**：

     ```cpp
     int myArray[5] = {1, 2};
     ```

   - **效果**：未显式初始化的元素自动初始化为0。

   

7. **聚合初始化**：

   - **语法**：`ElementType arrayName[ArraySize]{element1, element2, ...};`

   - **作用**：提供另一种简洁的初始化方式，特别是在初始化聚合类型时。

   - **示例**：

     ```cpp
     int myArray[5]{1, 2, 3};
     ```

   - **效果**：未指定的元素将被初始化为默认值0。

   

8. **初始化注意事项**：

   - **语法**：`ElementType arrayName[ArraySize] = {element1, element2, ...};`

   - **作用**：确保数组不会被过多元素初始化，避免潜在的运行时错误。

   - **示例**：

     ```cpp
     int myArray[3] = {1, 2, 3, 4}; // 编译错误
     ```

   - **效果**：如果初始化元素超出数组大小，编译器会报错。



### 10.3 数组访问

1. **索引访问**：

   - **语法**：`arrayName[index]`

   - **作用**：访问或修改数组中特定索引位置的元素。

   - **示例**

     ```
     cppCopy codeint myArray[5] = {1, 2, 3, 4, 5};
     std::cout << myArray[0]; // 访问第一个元素
     ```

   - **效果**：输出 `1`，即数组的第一个元素。

2. **越界访问**：

   - **语法**：`arrayName[index]`（其中 `index` 超出数组的实际大小）

   - **作用**：尝试访问数组的界限之外，通常是错误的。

   - **示例**

     ```
     cppCopy code
     std::cout << myArray[5]; // 尝试访问不存在的第六个元素
     ```

   - **效果**：未定义行为，可能导致程序崩溃或输出垃圾值。

3. **循环遍历**：

   - **语法**：使用 `for` 循环遍历数组。

   - **作用**：遍历数组的每个元素。

   - **示例**

     ```
     cppCopy codefor(int i = 0; i < 5; i++) {
         std::cout << myArray[i] << " ";
     }
     ```

   - **效果**：打印数组的所有元素。

4. **指针和数组访问**：

   - **语法**：`*(arrayName + index)`

   - **作用**：通过指针算术访问数组元素。

   - **示例**

     ```
     cppCopy code
     std::cout << *(myArray + 2); // 访问第三个元素
     ```

   - **效果**：输出 `3`，即数组的第三个元素。

5. **引用数组元素**：

   - **语法**：`ElementType& ref = arrayName[index];`

   - **作用**：通过引用修改数组中的元素。

   - **示例**

     ```
     cppCopy codeint& ref = myArray[2];
     ref = 10;
     std::cout << myArray[2];
     ```

   - **效果**：将数组的第三个元素修改为 `10` 并输出。

6. **多维数组访问**：

   - **语法**：`arrayName[index1][index2]`

   - **作用**：访问多维数组中的元素。

   - **示例**

     ```
     cppCopy codeint my2DArray[3][4];
     my2DArray[1][2] = 5;
     ```

   - **效果**：修改第二行第三列的元素为 `5`。

7. **const数组**：

   - **语法**：`const ElementType arrayName[ArraySize];`

   - **作用**：创建一个不可修改的数组。

   - **示例**

     ```
     cppCopy codeconst int myConstArray[5] = {1, 2, 3, 4, 5};
     // myConstArray[0] = 10; // 编译错误
     ```

   - **效果**：尝试修改 `const` 数组的元素会导致编译错误。

8. **范围基于的for循环**（自C++11起）：

   - **语法**：`for(ElementType x : arrayName)`

   - **作用**：简化数组的遍历。

   - **示例**

     ```
     cppCopy codefor(int x : myArray) {
         std::cout << x << " ";
     }
     ```

   - **效果**：打印数组的所有元素。



### 10.4 数组遍历

1. **传统的for循环遍历**：

   - **语法**：`for(int i = 0; i < ArraySize; ++i) { /* 访问 arrayName[i] */ }`

   - **作用**：逐个访问数组的每个元素。

   - 示例

     ```
     cppCopy codeint myArray[5] = {1, 2, 3, 4, 5};
     for(int i = 0; i < 5; ++i) {
         std::cout << myArray[i] << " ";
     }
     ```

   - **效果**：输出数组 `myArray` 的所有元素：`1 2 3 4 5 `。

2. **基于范围的for循环（自C++11起）**：

   - **语法**：`for(auto element : arrayName) { /* 使用 element */ }`

   - **作用**：简化遍历数组的操作，无需处理索引。

   - 示例

     ```
     cppCopy codefor(int elem : myArray) {
         std::cout << elem << " ";
     }
     ```

   - **效果**：同样输出数组 `myArray` 的所有元素：`1 2 3 4 5 `。

3. **使用指针遍历数组**：

   - **语法**：`for(ElementType* ptr = arrayName; ptr != arrayName + ArraySize; ++ptr) { /* 使用 *ptr */ }`

   - **作用**：通过指针遍历数组，提供更底层的访问方式。

   - 示例

     ```
     cppCopy codefor(int *ptr = myArray; ptr != myArray + 5; ++ptr) {
         std::cout << *ptr << " ";
     }
     ```

   - **效果**：输出数组 `myArray` 的所有元素：`1 2 3 4 5 `。

4. **遍历多维数组**：

   - **语法**：使用嵌套循环 `for(int i = 0; i < Dim1Size; ++i) { for(int j = 0; j < Dim2Size; ++j) { /* 访问 arrayName[i][j] */ } }`

   - **作用**：逐个访问多维数组的每个元素。

   - 示例

     ```
     cppCopy codeint my2DArray[2][3] = {{1, 2, 3}, {4, 5, 6}};
     for(int i = 0; i < 2; ++i) {
         for(int j = 0; j < 3; ++j) {
             std::cout << my2DArray[i][j] << " ";
         }
     }
     ```

   - **效果**：输出二维数组 `my2DArray` 的所有元素：`1 2 3 4 5 6 `。

5. **使用std::begin() 和 std::end()**：

   - **语法**：`for(auto it = std::begin(arrayName); it != std::end(arrayName); ++it) { /* 使用 *it */ }`

   - **作用**：使用迭代器遍历数组，适用于数组大小不明确的情况。

   - 示例

     ```
     cppCopy codefor(auto it = std::begin(myArray); it != std::end(myArray); ++it) {
         std::cout << *it << " ";
     }
     ```

   - **效果**：输出数组 `myArray` 的所有元素：`1 2 3 4 5 `。

每种遍历方法都有其独特的用途和优势。理解这些不同的遍历技术及其适用场景对于编写高效和可读的C++代码至关重要。



### 10.5 数组练习

1. 选择排序

选择排序（Selection Sort）是一种简单直观的排序算法。它的基本思想是：在未排序的序列中找到最小（或最大）的元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（或最大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。



**算法步骤**

1. 从数组的当前位置开始，向后查找最小（或最大）元素。
2. 将找到的最小（或最大）元素和当前位置的元素交换。
3. 对数组的剩余部分重复步骤1和2。

```cpp
#include <iostream>

int main() {
	int arr[] = {9,3,11,35,4,6,3,19,24,83,10,67,45,63,91,35,48,69,26,56,91,35};
	int arrsize = sizeof(arr) / sizeof(arr[0]);

	for (int i = 0; i < arrsize - 1; i++) {
        // 寻找最小元素索引
		int minIndex = i;
		for (int j = i + 1; j < arrsize; j++) {
			if (arr[j] < arr[minIndex]) {
				minIndex = j;
			}
		}
		//找到之后交换数值
		std::swap(arr[i], arr[minIndex]);
	}

    // 打印输出
	for (int i = 0; i < arrsize; i++) {
		std::cout << arr[i] << '\n';
	}
}
```



2. 冒泡排序

冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地遍历要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。



**算法步骤**

1. 比较相邻的元素。如果第一个比第二个大，就交换它们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

```cpp
#include <iostream>

int main() {
	int arr[] = {9,3,11,35,4,6,3,19,24,83,10,67,45,63,91,35,48,69,26,56,91,35};

	int arrsize = sizeof(arr) / sizeof(arr[0]);

	for (int j = 0; j < arrsize - 1; j++) {
		bool swaped = false;
		for (int i = 0; i < arrsize - 1 -j; i++) {
			if (arr[i] > arr[i + 1]) {
				std::swap(arr[i], arr[i + 1]);
				swaped = true;
			}
		}

		//如果一次交换都没发送，提取结束
		if (!swaped) {
			break; 
		}
	}

	for (int i = 0; i < arrsize; i++) {
		std::cout << arr[i] << '\n';
	}
}
```

> 选择排序和冒泡排序的区别：
>
> 1. 选择排序是从开头，跟之后的每一个元素进行比较
> 2. 冒泡排序是相邻的元素间进行比较
